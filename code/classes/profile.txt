Loading file files/9x9.txt
1011 sudokus have been found in this file.
Which one should we solve ?

Found learning clause:  {897, 775, 777, 525, 527, 785, 535, 537, 795, 797, 925, 927, 545, 547, 935, 937, 817, 565, 567, 825, 827, 575, 577, 837, 327, 585, 715, 587, 975, 337, 977, 595, 725, 597, 217, 735, 227, 995, 997, 875, 237, 877, 117, 885, 887, -132, 127}
backtracking:  1
done
Found learning clause:  {519, 525, 526, 527, 528, 535, 536, 537, 538, 541, 542, 543, 545, 547, 548, 551, 558, 561, 562, 563, 565, 567, 568, 575, 577, 578, 585, 587, 595, 597, 598, 616, 626, 627, 628, 117, 118, 119, 636, 638, 127, 128, 641, 645, 647, 138, 651, 653, 655, 143, 153, 158, 163, 178, 188, 198, 715, 719, 722, 724, 725, 217, 221, 222, 223, 734, 735, 224, 227, 225, 229, 742, 231, 743, 233, 744, 747, 234, 235, 237, 238, 752, 753, 754, 243, 247, 762, 763, 764, 253, 772, 263, 775, 777, 782, 785, 792, 795, 797, 819, 825, 826, 827, 327, 847, 337, 342, 343, 856, 347, 862, 863, 866, 875, 876, 877, 885, 886, 887, -136, 897, 919, 925, 927, 935, 942, 947, 438, 953, 441, 445, 962, 451, 454, 455, 456, 458, 459, 971, 972, 975, 465, 977, 978, 979, 478, 995, 997, 498}
backtracking:  1
done
Found learning clause:  {256, 772, 266, 526, 272, 543, 548, 553, 563, 826, 572, 326, 336, 848, 346, 348, 356, 872, 366, -142, 626, 116, 629, 381, 126, 639, 384, 385, 383, 387, 388, 389, 136, 649, 653, 659, 663, 156, 669, 926, 161, 163, 164, 165, 166, 167, 169, 431, 432, 689, 434, 435, 948, 437, 438, 699, 443, 448, 972, 463, 726, 472, 748}
backtracking:  2
done
Found learning clause:  {384, 294, 394, -144, 274, 374, 184, 284}
backtracking:  2
done
Found learning clause:  {513, 523, 783, 271, 274, 533, 279, 284, 542, 543, 289, 548, 294, 553, 299, 563, 823, 571, 848, 342, 348, 863, 871, 873, -146, 623, 112, 883, 371, 629, 374, 118, 633, 122, 893, 639, 384, 128, 132, 389, 649, 394, 138, 653, 142, 399, 659, 663, 669, 158, 423, 171, 942, 689, 178, 948, 182, 184, 442, 443, 699, 189, 188, 448, 192, 198, 971, 972, 975, 976, 977, 978, 979, 723, 463, 471, 742, 743, 748, 753, 763}
backtracking:  2
done

SAT!
Sudoku answer: 
111: True
123: True
137: True
148: True
159: True
162: True
174: True
185: True
196: True
212: True
228: True
239: True
246: True
254: True
265: True
277: True
283: True
291: True
316: True
325: True
334: True
341: True
357: True
363: True
379: True
382: True
398: True
418: True
426: True
433: True
447: True
452: True
461: True
475: True
484: True
499: True
517: True
522: True
531: True
549: True
555: True
564: True
576: True
588: True
593: True
619: True
624: True
635: True
643: True
656: True
668: True
672: True
681: True
697: True
713: True
727: True
732: True
745: True
758: True
769: True
771: True
786: True
794: True
814: True
821: True
836: True
842: True
853: True
867: True
878: True
889: True
895: True
915: True
929: True
938: True
944: True
951: True
966: True
973: True
987: True
992: True

Time: 6.636523485183716
Total duration: 17.0307s
File: C:\Users\bdode\Documents\Website_projects\SAT\working_learning\SAT-44\code\classes\CNF.py
File duration: 17.0247s (99.96%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|# File containing classes to represents a CNF formula
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|import math
     4|         0|            0|            0|  0.00%|import linecache
     5|         0|            0|            0|  0.00%|import time
     6|         0|            0|            0|  0.00%|from iteration_utilities import first
     7|         0|            0|            0|  0.00%|
     8|         0|            0|            0|  0.00%|
     9|         0|            0|            0|  0.00%|
    10|         0|            0|            0|  0.00%|class CNF_Formula():
    11|         0|            0|            0|  0.00%|    """Represents a CNF_Formula, which is a conjuction of clauses"""
    12|         0|            0|            0|  0.00%|
    13|         1|            0|            0|  0.00%|    def __init__(self):
    14|         0|            0|            0|  0.00%|
    15|         0|            0|            0|  0.00%|        # The current recursive depth
    16|         1|            0|            0|  0.00%|        self.current_depth = 0
    17|         0|            0|            0|  0.00%|
    18|         0|            0|            0|  0.00%|        # Dict with variables thats are used to buid literal and thus clauses
    19|         1|            0|            0|  0.00%|        self.variable_dict = {}
    20|         0|            0|            0|  0.00%|
    21|         0|            0|            0|  0.00%|        # List of clauses which form the CNF
    22|         1|            0|            0|  0.00%|        self.clauses = {}
    23|         1|            0|            0|  0.00%|        self.active_clauses = set()
    24|         1|            0|            0|  0.00%|        self.clauses_removed_part = {}
    25|         0|            0|            0|  0.00%|
    26|         0|            0|            0|  0.00%|        # Hold the removed clauses like {"depth": [clauseid, clauseid]}
    27|         1|            0|            0|  0.00%|        self.removed_clauses = {}
    28|         0|            0|            0|  0.00%|
    29|         0|            0|            0|  0.00%|        # Hold the removed literals like {"depth": [[clauseid, literal], [clauseid, literal]]}
    30|         1|            0|            0|  0.00%|        self.removed_literals = {}
    31|         0|            0|            0|  0.00%|
    32|         0|            0|            0|  0.00%|        # History of the variables assigned by branching
    33|         1|            0|            0|  0.00%|        self.branch_history = {}
    34|         0|            0|            0|  0.00%|
    35|         0|            0|            0|  0.00%|
    36|         0|            0|            0|  0.00%|
    37|         0|            0|            0|  0.00%|
    38|         0|            0|            0|  0.00%|
    39|     19047|    0.0240233|  1.26126e-06|  0.14%|    def remove_clause(self, clause_index):
    40|         0|            0|            0|  0.00%|        """Correctly removes a clause"""
    41|         0|            0|            0|  0.00%|        # Remove clause from variable_occurs_in
    42|     36739|    0.0729067|  1.98445e-06|  0.43%|        for literal in self.clauses[str(clause_index)]:
    43|     17692|    0.0190208|  1.07511e-06|  0.11%|            if literal < 0:
    44|     15898|    0.0350351|  2.20374e-06|  0.21%|                self.variable_dict[str(abs(literal))].occurs_negated_in.remove(clause_index)
    45|     17692|    0.0200114|   1.1311e-06|  0.12%|            if literal > 0:
    46|      1794|   0.00400472|  2.23228e-06|  0.02%|                self.variable_dict[str(abs(literal))].occurs_positive_in.remove(clause_index)
    47|         0|            0|            0|  0.00%|
    48|     19047|    0.0180159|  9.45863e-07|  0.11%|        self.active_clauses.remove(clause_index)
    49|         0|            0|            0|  0.00%|
    50|         0|            0|            0|  0.00%|        # Add to removed/depth log
    51|     19047|     0.023757|  1.24728e-06|  0.14%|        if str(self.current_depth) not in self.removed_clauses:
    52|         7|            0|            0|  0.00%|            self.removed_clauses[str(self.current_depth)] = []
    53|         0|            0|            0|  0.00%|
    54|     19047|    0.0319974|  1.67992e-06|  0.19%|        self.removed_clauses[str(self.current_depth)].append(clause_index)
    55|         0|            0|            0|  0.00%|
    56|         0|            0|            0|  0.00%|
    57|        20|            0|            0|  0.00%|    def undo_clause_remove(self, depth):
    58|         0|            0|            0|  0.00%|        """ Undos the removal of clauses at a specific height"""
    59|        20|            0|            0|  0.00%|        if str(depth) in self.removed_clauses:
    60|      7051|   0.00800848|  1.13579e-06|  0.05%|            for clause_index in self.removed_clauses[str(depth)]:
    61|         0|            0|            0|  0.00%|
    62|         0|            0|            0|  0.00%|                # Reactivate clause
    63|      7031|    0.0120115|  1.70837e-06|  0.07%|                self.active_clauses.add(clause_index)
    64|         0|            0|            0|  0.00%|
    65|         0|            0|            0|  0.00%|                # Re-add clause to variable_occurs_in
    66|     13099|    0.0140066|  1.06929e-06|  0.08%|                for literal in self.clauses[str(clause_index)]:
    67|      6068|   0.00800753|  1.31963e-06|  0.05%|                    if literal < 0:
    68|      5063|   0.00900912|   1.7794e-06|  0.05%|                        self.variable_dict[str(abs(literal))].occurs_negated_in.add(clause_index)
    69|      6068|   0.00801063|  1.32014e-06|  0.05%|                    if literal > 0:
    70|      1005|   0.00100088|  9.95902e-07|  0.01%|                        self.variable_dict[str(abs(literal))].occurs_positive_in.add(clause_index)
    71|         0|            0|            0|  0.00%|
    72|         0|            0|            0|  0.00%|        # Reset removed_clauses at that depth
    73|        20|            0|            0|  0.00%|        self.removed_clauses[str(depth)] = []
    74|         0|            0|            0|  0.00%|
    75|         0|            0|            0|  0.00%|
    76|     24929|    0.0249476|  1.00075e-06|  0.15%|    def remove_literal(self, clause_index, literal):
    77|         0|            0|            0|  0.00%|        """"Propely removes a literal"""
    78|         0|            0|            0|  0.00%|
    79|         0|            0|            0|  0.00%|        # Remove from variable.occurs_in
    80|     24929|    0.0280225|  1.12409e-06|  0.16%|        if literal < 0:
    81|     19502|    0.0331218|  1.69838e-06|  0.19%|            self.variable_dict[str(abs(literal))].occurs_negated_in.remove(clause_index)
    82|     24929|    0.0340397|  1.36547e-06|  0.20%|        if literal > 0:
    83|      5427|   0.00700641|  1.29103e-06|  0.04%|            self.variable_dict[str(abs(literal))].occurs_positive_in.remove(clause_index)
    84|         0|            0|            0|  0.00%|
    85|     24929|    0.0397151|  1.59313e-06|  0.23%|        self.clauses[str(clause_index)].remove(literal)
    86|         0|            0|            0|  0.00%|
    87|         0|            0|            0|  0.00%|        # Add to removed literals history
    88|     24929|    0.0430467|  1.72677e-06|  0.25%|        if str(self.current_depth) not in self.removed_literals:
    89|         7|            0|            0|  0.00%|            self.removed_literals[str(self.current_depth)] = []
    90|     24929|    0.0410397|  1.64626e-06|  0.24%|        self.removed_literals[str(self.current_depth)].append([clause_index, literal])
    91|         0|            0|            0|  0.00%|
    92|         0|            0|            0|  0.00%|        # Add to removed part of clauses
    93|     24929|    0.0410447|  1.64646e-06|  0.24%|        if str(clause_index) not in self.clauses_removed_part:
    94|     12016|    0.0150011|  1.24842e-06|  0.09%|            self.clauses_removed_part[str(clause_index)] = []
    95|     24929|    0.0410428|  1.64639e-06|  0.24%|        self.clauses_removed_part[str(clause_index)].append(literal)
    96|         0|            0|            0|  0.00%|
    97|         0|            0|            0|  0.00%|
    98|        20|            0|            0|  0.00%|    def undo_branch(self, depth):
    99|         0|            0|            0|  0.00%|        """Undos a branch at a specigic depth"""
   100|        20|            0|            0|  0.00%|        if str(depth) in self.branch_history:
   101|       990|            0|            0|  0.00%|            for var in self.branch_history[str(depth)]:
   102|       970|    0.0010016|  1.03257e-06|  0.01%|                self.variable_dict[str(var)].boolean = None
   103|       970|   0.00200129|  2.06318e-06|  0.01%|                self.variable_dict[str(var)].by_branch = None
   104|       970|   0.00100112|  1.03208e-06|  0.01%|                self.variable_dict[str(var)].set_depth = None
   105|       970|     0.002002|  2.06392e-06|  0.01%|                self.variable_dict[str(var)].caused_by_clause_id = None
   106|        20|            0|            0|  0.00%|            self.branch_history[str(depth)] = []
   107|        20|            0|            0|  0.00%|        self.undo_clause_remove(depth)
(call)|        20|    0.0600548|   0.00300274|  0.35%|# C:\Users\bdode\Documents\Website_projects\SAT\working_learning\SAT-44\code\classes\CNF.py:57 undo_clause_remove
   108|        20|            0|            0|  0.00%|        self.undo_literal_remove(depth)
(call)|        20|    0.0880821|    0.0044041|  0.52%|# C:\Users\bdode\Documents\Website_projects\SAT\working_learning\SAT-44\code\classes\CNF.py:111 undo_literal_remove
   109|         0|            0|            0|  0.00%|
   110|         0|            0|            0|  0.00%|
   111|        20|            0|            0|  0.00%|    def undo_literal_remove(self, depth):
   112|         0|            0|            0|  0.00%|        """undos the removal of literals at a specific depth"""
   113|         0|            0|            0|  0.00%|
   114|        20|            0|            0|  0.00%|        if str(depth) in self.removed_literals:
   115|      9998|    0.0120108|  1.20132e-06|  0.07%|            for clause_index, literal in self.removed_literals[str(depth)]:
   116|         0|            0|            0|  0.00%|
   117|         0|            0|            0|  0.00%|                # Re-add literal
   118|      9978|     0.017015|  1.70525e-06|  0.10%|                self.clauses[str(clause_index)].add(literal)
   119|         0|            0|            0|  0.00%|
   120|         0|            0|            0|  0.00%|                # Re add to occurs_in
   121|      9978|   0.00900745|  9.02731e-07|  0.05%|                if literal < 0:
   122|      7044|    0.0130088|   1.8468e-06|  0.08%|                    self.variable_dict[str(abs(literal))].occurs_negated_in.add(clause_index)
   123|      9978|    0.0180221|  1.80618e-06|  0.11%|                if literal > 0:
   124|      2934|   0.00200009|  6.81695e-07|  0.01%|                    self.variable_dict[str(abs(literal))].occurs_positive_in.add(clause_index)
   125|         0|            0|            0|  0.00%|
   126|      9978|    0.0170178|  1.70554e-06|  0.10%|                self.clauses_removed_part[str(clause_index)].remove(literal)
   127|         0|            0|            0|  0.00%|
   128|         0|            0|            0|  0.00%|        # Reset removed_clauses at that depth
   129|        20|            0|            0|  0.00%|        self.removed_literals[str(depth)] = []
   130|         0|            0|            0|  0.00%|
   131|         0|            0|            0|  0.00%|
   132|      1699|   0.00400329|  2.35626e-06|  0.02%|    def branch(self, variable, boolean):
   133|         0|            0|            0|  0.00%|        """Branch the clauses by changing a variable to a boolean"""
   134|         0|            0|            0|  0.00%|
   135|         0|            0|            0|  0.00%|        # Set variable to boolean
   136|      1699|   0.00100136|  5.89381e-07|  0.01%|        self.variable_dict[str(variable)].boolean = boolean
   137|      1699|   0.00400543|  2.35752e-06|  0.02%|        self.variable_dict[str(variable)].by_branch = True
   138|      1699|   0.00406218|  2.39092e-06|  0.02%|        self.variable_dict[str(variable)].set_depth = self.current_depth
   139|         0|            0|            0|  0.00%|
   140|      1699|     0.002002|  1.17834e-06|  0.01%|        if boolean:
   141|         0|            0|            0|  0.00%|
   142|         0|            0|            0|  0.00%|            # Remove clause if its satisfies the clause
   143|      1707|   0.00600863|  3.51999e-06|  0.04%|            for clause_index in self.variable_dict[str(variable)].occurs_positive_in.copy():
   144|      1366|   0.00600505|  4.39608e-06|  0.04%|                self.remove_literal(clause_index, variable)
(call)|      1366|    0.0170159|  1.24568e-05|  0.10%|# C:\Users\bdode\Documents\Website_projects\SAT\working_learning\SAT-44\code\classes\CNF.py:76 remove_literal
   145|      1366|   0.00800753|  5.86203e-06|  0.05%|                self.remove_clause(clause_index)
(call)|      1366|    0.0250244|  1.83195e-05|  0.15%|# C:\Users\bdode\Documents\Website_projects\SAT\working_learning\SAT-44\code\classes\CNF.py:39 remove_clause
   146|         0|            0|            0|  0.00%|
   147|         0|            0|            0|  0.00%|            # Only remove literal if clause not satisfied
   148|      2157|   0.00200057|  9.27478e-07|  0.01%|            for clause_index in self.variable_dict[str(variable)].occurs_negated_in.copy():
   149|      1816|   0.00500488|  2.75599e-06|  0.03%|                self.remove_literal(clause_index, -1*variable)
(call)|      1816|    0.0230205|  1.26765e-05|  0.14%|# C:\Users\bdode\Documents\Website_projects\SAT\working_learning\SAT-44\code\classes\CNF.py:76 remove_literal
   150|         0|            0|            0|  0.00%|
   151|      1699|   0.00400352|   2.3564e-06|  0.02%|        if not boolean:
   152|         0|            0|            0|  0.00%|            # Only remove literal if clause not satisfied
   153|      5076|   0.00700593|  1.38021e-06|  0.04%|            for clause_index in self.variable_dict[str(variable)].occurs_positive_in.copy():
   154|      3718|    0.0170152|  4.57644e-06|  0.10%|                self.remove_literal(clause_index, (variable))
(call)|      3718|    0.0580592|  1.56157e-05|  0.34%|# C:\Users\bdode\Documents\Website_projects\SAT\working_learning\SAT-44\code\classes\CNF.py:76 remove_literal
   155|         0|            0|            0|  0.00%|
   156|         0|            0|            0|  0.00%|            # Remove clause if its satisfies the clause
   157|     19039|    0.0320296|  1.68232e-06|  0.19%|            for clause_index in self.variable_dict[str(variable)].occurs_negated_in.copy():
   158|     17681|    0.0550554|  3.11382e-06|  0.32%|                self.remove_literal(clause_index, -1 *variable)
(call)|     17681|     0.245933|  1.39094e-05|  1.44%|# C:\Users\bdode\Documents\Website_projects\SAT\working_learning\SAT-44\code\classes\CNF.py:76 remove_literal
   159|     17681|    0.0720773|  4.07654e-06|  0.42%|                self.remove_clause(clause_index)
(call)|     17681|     0.223748|  1.26547e-05|  1.31%|# C:\Users\bdode\Documents\Website_projects\SAT\working_learning\SAT-44\code\classes\CNF.py:39 remove_clause
   160|         0|            0|            0|  0.00%|
   161|      1699|   0.00200152|  1.17806e-06|  0.01%|        if not str(self.current_depth) in self.branch_history:
   162|         7|            0|            0|  0.00%|            self.branch_history[str(self.current_depth)] = []
   163|      1699|   0.00200176|   1.1782e-06|  0.01%|        self.branch_history[str(self.current_depth)].append(variable)
   164|         0|            0|            0|  0.00%|
   165|        13|            0|            0|  0.00%|    def pick_active_variable(self, heuristic_name):
   166|         0|            0|            0|  0.00%|        """Picks the variable which will be branched"""
   167|         0|            0|            0|  0.00%|        # Returns first literal (actually random though) of first active clause
   168|         0|            0|            0|  0.00%|
   169|        13|            0|            0|  0.00%|        if heuristic_name == "pick-first":
   170|         0|            0|            0|  0.00%|            return abs(first(self.clauses[str(sorted(self.active_clauses)[0])]))
   171|         0|            0|            0|  0.00%|
   172|        13|            0|            0|  0.00%|        if heuristic_name == "lowest":
   173|        13|            0|            0|  0.00%|            lowest_var = 13337
   174|     16474|    0.0220208|   1.3367e-06|  0.13%|            for clause_id in self.active_clauses:
   175|     53557|    0.0600562|  1.12135e-06|  0.35%|                for literal in self.clauses[str(clause_id)]:
   176|     37096|    0.0640578|  1.72681e-06|  0.38%|                    if abs(literal) < lowest_var:
   177|        92|            0|            0|  0.00%|                        lowest_var = abs(literal)
   178|        13|            0|            0|  0.00%|            return lowest_var
   179|         0|            0|            0|  0.00%|
   180|         0|            0|            0|  0.00%|
   181|         0|            0|            0|  0.00%|
   182|         0|            0|            0|  0.00%|
   183|         0|            0|            0|  0.00%|
   184|         0|            0|            0|  0.00%|
   185|        19|            0|            0|  0.00%|    def remove_unit_clauses(self):
   186|         0|            0|            0|  0.00%|        """Remove unit clauses and add it to removed clauses"""
   187|        19|            0|            0|  0.00%|        restart = True
   188|      1724|   0.00300264|  1.74167e-06|  0.02%|        while restart == True:
   189|      1705|   0.00200152|  1.17391e-06|  0.01%|            restart = False
   190|   1750526|      2.14951|  1.22792e-06| 12.62%|            for clause_id in self.active_clauses:
   191|   1750507|      2.73166|   1.5605e-06| 16.04%|                if len(self.clauses[str(clause_id)]) == 1:
   192|      1686|   0.00200224|  1.18757e-06|  0.01%|                    literal = first(self.clauses[str(clause_id)])
   193|         0|            0|            0|  0.00%|
   194|         0|            0|            0|  0.00%|                    # We save unit clauses in the minus version of the current depth
   195|      1686|    0.0010004|   5.9336e-07|  0.01%|                    self.current_depth *= -1
   196|      1686|   0.00400019|  2.37259e-06|  0.02%|                    boolean = (literal > 0)
   197|      1686|    0.0130112|  7.71721e-06|  0.08%|                    self.branch(abs(literal), boolean)
(call)|      1686|     0.824089|  0.000488784|  4.84%|# C:\Users\bdode\Documents\Website_projects\SAT\working_learning\SAT-44\code\classes\CNF.py:132 branch
   198|      1686|   0.00100112|  5.93784e-07|  0.01%|                    self.current_depth *= -1
   199|         0|            0|            0|  0.00%|
   200|         0|            0|            0|  0.00%|                    # Save implication_graph_info
   201|      1686|  0.000899553|  5.33543e-07|  0.01%|                    self.variable_dict[str(abs(literal))].by_branch = False
   202|      1686|   0.00500584|  2.96906e-06|  0.03%|                    self.variable_dict[str(abs(literal))].set_depth = self.current_depth
   203|      1686|   0.00300384|  1.78163e-06|  0.02%|                    self.variable_dict[str(abs(literal))].caused_by_clause_id = clause_id
   204|         0|            0|            0|  0.00%|
   205|         0|            0|            0|  0.00%|                    # We want to reset the search for unit clauses because new ones could have been created
   206|      1686|   0.00200129|    1.187e-06|  0.01%|                    restart = True
   207|      1686|   0.00200176|  1.18728e-06|  0.01%|                    break
   208|         0|            0|            0|  0.00%|
   209|         0|            0|            0|  0.00%|
   210|        10|            0|            0|  0.00%|    def undo_unit_clauses(self):
   211|        10|    0.0010004|   0.00010004|  0.01%|        self.undo_branch(self.current_depth * -1)
(call)|        10|     0.152141|    0.0152141|  0.89%|# C:\Users\bdode\Documents\Website_projects\SAT\working_learning\SAT-44\code\classes\CNF.py:98 undo_branch
   212|         0|            0|            0|  0.00%|
   213|         1|            0|            0|  0.00%|    def remove_pure_literals(self):
   214|         0|            0|            0|  0.00%|        """Remove all clauses with pure literals"""
   215|       730|   0.00100088|  1.37107e-06|  0.01%|        for variable in self.variable_dict:
   216|       729|            0|            0|  0.00%|            variable = self.variable_dict[variable]
   217|         0|            0|            0|  0.00%|
   218|       729|   0.00100112|  1.37328e-06|  0.01%|            if not variable.occurs_negated_in.copy():
   219|         0|            0|            0|  0.00%|                self.branch(int(variable.variable_name), True)
   220|         0|            0|            0|  0.00%|
   221|       729|   0.00200176|   2.7459e-06|  0.01%|            elif not variable.occurs_positive_in.copy():
   222|         0|            0|            0|  0.00%|                self.branch(int(variable.variable_name), False)
   223|         0|            0|            0|  0.00%|
   224|         0|            0|            0|  0.00%|        # Clear history, you dont want to turn this back
   225|         1|            0|            0|  0.00%|        if str(0) in self.removed_clauses:
   226|         0|            0|            0|  0.00%|            del self.removed_clauses[str(0)]
   227|         1|            0|            0|  0.00%|        if str(0) in self.removed_literals:
   228|         0|            0|            0|  0.00%|            del self.removed_literals[str(0)]
   229|         1|            0|            0|  0.00%|        if str(0) in self.branch_history:
   230|         0|            0|            0|  0.00%|            del self.branch_history[str(0)]
   231|         0|            0|            0|  0.00%|
   232|         0|            0|            0|  0.00%|    def remove_tautologies(self):
   233|         0|            0|            0|  0.00%|        """Removes all the clauses containing a tautology"""
   234|         0|            0|            0|  0.00%|        # Check for every variable if it is both in negated and postive form in the same clause
   235|         0|            0|            0|  0.00%|        for variable in self.variable_dict:
   236|         0|            0|            0|  0.00%|            variable = self.variable_dict[variable]
   237|         0|            0|            0|  0.00%|            for occurs_negated in variable.occurs_negated_in.copy():
   238|         0|            0|            0|  0.00%|                if occurs_negated in variable.occurs_positive_in:
   239|         0|            0|            0|  0.00%|                    self.remove_clause(occurs_negated)
   240|         0|            0|            0|  0.00%|
   241|         0|            0|            0|  0.00%|        # Clear history, you dont want to turn this back
   242|         0|            0|            0|  0.00%|        if str(0) in self.removed_clauses:
   243|         0|            0|            0|  0.00%|            del self.removed_clauses[str(0)]
   244|         0|            0|            0|  0.00%|        if str(0) in self.removed_literals:
   245|         0|            0|            0|  0.00%|            del self.removed_literals[str(0)]
   246|         0|            0|            0|  0.00%|        if str(0) in self.branch_history:
   247|         0|            0|            0|  0.00%|            del self.branch_history[str(0)]
   248|         0|            0|            0|  0.00%|
   249|         5|            0|            0|  0.00%|    def learn_clause(self, conflict_id):
   250|         0|            0|            0|  0.00%|        # self.print_total_status()
   251|         5|            0|            0|  0.00%|        partial_clause = set(self.clauses_removed_part[conflict_id])
   252|         0|            0|            0|  0.00%|
   253|         0|            0|            0|  0.00%|        # print("LEARNING CLAUSE: ", conflict_id)
   254|         0|            0|            0|  0.00%|        while True:
   255|         0|            0|            0|  0.00%|            #print(partial_clause)
   256|         0|            0|            0|  0.00%|
   257|         0|            0|            0|  0.00%|            # Count amount that have current depth_level
   258|       430|   0.00100112|  2.32819e-06|  0.01%|            current_depth_amount = 0
   259|     44803|     0.071064|  1.58614e-06|  0.42%|            for literal in partial_clause:
   260|         0|            0|            0|  0.00%|
   261|     44373|    0.0940578|  2.11971e-06|  0.55%|                if self.variable_dict[str(abs(literal))].set_depth == self.current_depth:
   262|      4060|   0.00400329|  9.86031e-07|  0.02%|                    current_depth_amount += 1
   263|       430|   0.00100064|  2.32708e-06|  0.01%|            if current_depth_amount == 1:
   264|         5|            0|            0|  0.00%|                break
   265|         0|            0|            0|  0.00%|
   266|         0|            0|            0|  0.00%|            # Expand first literal
   267|     18921|    0.0360341|  1.90445e-06|  0.21%|            for literal in partial_clause:
   268|     18921|    0.0410376|  2.16889e-06|  0.24%|                if (self.variable_dict[str(abs(literal))].by_branch == False
   269|     18823|    0.0380349|  2.02066e-06|  0.22%|                and self.variable_dict[str(abs(literal))].set_depth == self.current_depth
   270|       425|            0|            0|  0.00%|                and self.variable_dict[str(abs(literal))].caused_by_clause_id != None ):
   271|      3301|    0.0120115|  3.63875e-06|  0.07%|                    partial_clause = partial_clause | {literal for literal in self.clauses_removed_part[str(self.variable_dict[str(abs(literal))].caused_by_clause_id)] if literal not in partial_clause}
(call)|       425|   0.00500584|  1.17784e-05|  0.03%|# C:\Users\bdode\Documents\Website_projects\SAT\working_learning\SAT-44\code\classes\CNF.py:271 <setcomp>
   272|       425|    0.0010016|   2.3567e-06|  0.01%|                    self.variable_dict[str(abs(literal))].caused_by_branch = True
   273|         0|            0|            0|  0.00%|                    # print("expanded: ", partial_clause)
   274|       425|   0.00100207|  2.35782e-06|  0.01%|                    break
   275|         0|            0|            0|  0.00%|
   276|         0|            0|            0|  0.00%|            else:
   277|         0|            0|            0|  0.00%|                print("no literal to expand found, error")
   278|         0|            0|            0|  0.00%|                exit()
   279|         0|            0|            0|  0.00%|
   280|         0|            0|            0|  0.00%|            # Resolve the parial:
   281|       425|            0|            0|  0.00%|            literal_counter = 0
   282|     45206|    0.0920849|  2.03701e-06|  0.54%|            while literal_counter < len(partial_clause):
   283|     44781|    0.0650327|  1.45224e-06|  0.38%|                if -1*literal in partial_clause:
   284|       425|            0|            0|  0.00%|                    partial_clause.remove(literal)
   285|       425|            0|            0|  0.00%|                    partial_clause.remove(-1*literal)
   286|         0|            0|            0|  0.00%|                else:
   287|     44356|    0.0671148|  1.51309e-06|  0.39%|                    literal_counter += 1
   288|         0|            0|            0|  0.00%|
   289|         5|            0|            0|  0.00%|        print("Found learning clause: ", partial_clause)
(call)|        20|            0|            0|  0.00%|# C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.8_3.8.1520.0_x64__qbz5n2kfra8p0\lib\encodings\cp1252.py:18 encode
   290|         0|            0|            0|  0.00%|
   291|         0|            0|            0|  0.00%|        # Find highest depth that is not the current depth:
   292|         5|            0|            0|  0.00%|        highest_depth = -1
   293|         0|            0|            0|  0.00%|
   294|         0|            0|            0|  0.00%|        # Unit clauses always have to go back to depth 0
   295|         5|            0|            0|  0.00%|        if len(partial_clause) == 1:
   296|         0|            0|            0|  0.00%|            highest_depth = 0
   297|         0|            0|            0|  0.00%|        else:
   298|       353|            0|            0|  0.00%|            for literal in partial_clause:
   299|         0|            0|            0|  0.00%|                # print(literal)
   300|         0|            0|            0|  0.00%|                # print(self.current_depth, self.variable_dict[str(abs(literal))].set_depth, highest_depth)
   301|       348|   0.00200343|  5.75699e-06|  0.01%|                if self.current_depth > self.variable_dict[str(abs(literal))].set_depth > highest_depth:
   302|         9|   0.00100064|  0.000111183|  0.01%|                    highest_depth = self.variable_dict[str(abs(literal))].set_depth
   303|         0|            0|            0|  0.00%|
   304|         5|            0|            0|  0.00%|        if highest_depth == -1:
   305|         0|            0|            0|  0.00%|            print("Error: found invalid highest depth")
   306|         0|            0|            0|  0.00%|            exit()
   307|         0|            0|            0|  0.00%|
   308|         0|            0|            0|  0.00%|        # print("depth height: ", highest_depth)
   309|         0|            0|            0|  0.00%|
   310|         0|            0|            0|  0.00%|        # Add learned clause to clauses:
   311|         5|            0|            0|  0.00%|        clause_id = len(self.clauses)
   312|         5|            0|            0|  0.00%|        self.clauses[str(clause_id)] = set(partial_clause)
   313|         5|            0|            0|  0.00%|        self.active_clauses.add(clause_id)
   314|         0|            0|            0|  0.00%|
   315|         0|            0|            0|  0.00%|        # Updat var counters
   316|       353|            0|            0|  0.00%|        for literal in partial_clause:
   317|       348|  0.000876665|  2.51915e-06|  0.01%|            if literal < 0:
   318|         5|            0|            0|  0.00%|                self.variable_dict[str(abs(literal))].occurs_negated_in.add(clause_id)
   319|         0|            0|            0|  0.00%|            else:
   320|       343|   0.00112486|  3.27947e-06|  0.01%|                self.variable_dict[str(abs(literal))].occurs_positive_in.add(clause_id)
   321|         0|            0|            0|  0.00%|
   322|         0|            0|            0|  0.00%|        # We also need to remove literals if already set to boolean
   323|       353|            0|            0|  0.00%|        for literal in partial_clause:
   324|       348|  6.67572e-06|  1.91831e-08|  0.00%|            if literal < 0:
   325|         5|            0|            0|  0.00%|                if self.variable_dict[str(abs(literal))].boolean == True:
   326|         5|            0|            0|  0.00%|                    correct_depth = self.current_depth
   327|         5|            0|            0|  0.00%|                    self.current_depth = self.variable_dict[str(abs(literal))].set_depth
   328|         5|            0|            0|  0.00%|                    self.remove_literal(clause_id, literal)
(call)|         5|            0|            0|  0.00%|# C:\Users\bdode\Documents\Website_projects\SAT\working_learning\SAT-44\code\classes\CNF.py:76 remove_literal
   329|         5|            0|            0|  0.00%|                    self.current_depth = correct_depth
   330|         5|            0|            0|  0.00%|                if self.variable_dict[str(abs(literal))] == False:
   331|         0|            0|            0|  0.00%|                    print("Error")
   332|         0|            0|            0|  0.00%|                    exit()
   333|         0|            0|            0|  0.00%|
   334|       348|            0|            0|  0.00%|            if literal > 0:
   335|       343|            0|            0|  0.00%|                if self.variable_dict[str(abs(literal))].boolean == False:
   336|       343|            0|            0|  0.00%|                    correct_depth = self.current_depth
   337|       343|    0.0010004|  2.91663e-06|  0.01%|                    self.current_depth = self.variable_dict[str(abs(literal))].set_depth
   338|       343|   0.00100112|  2.91872e-06|  0.01%|                    self.remove_literal(clause_id, literal)
(call)|       343|   0.00399971|   1.1661e-05|  0.02%|# C:\Users\bdode\Documents\Website_projects\SAT\working_learning\SAT-44\code\classes\CNF.py:76 remove_literal
   339|       343|   0.00150275|   4.3812e-06|  0.01%|                    self.current_depth = correct_depth
   340|       343|   0.00200224|  5.83743e-06|  0.01%|                if self.variable_dict[str(abs(literal))] == True:
   341|         0|            0|            0|  0.00%|                    print("Error")
   342|         0|            0|            0|  0.00%|                    exit()
   343|         0|            0|            0|  0.00%|
   344|         0|            0|            0|  0.00%|
   345|         5|            0|            0|  0.00%|        return highest_depth
   346|         0|            0|            0|  0.00%|
   347|         0|            0|            0|  0.00%|
   348|        17|            0|            0|  0.00%|    def contains_empty_clause(self):
   349|         0|            0|            0|  0.00%|        """Returns if the CNF contains an empty clause and is thus unsatisfiable"""
   350|         0|            0|            0|  0.00%|
   351|         0|            0|            0|  0.00%|        # Check if there exists a clause that is empty
   352|     14829|     0.017015|  1.14741e-06|  0.10%|        for clause_index in self.active_clauses:
   353|     14817|    0.0220199|  1.48612e-06|  0.13%|            if not self.clauses[str(clause_index)]:
   354|         5|            0|            0|  0.00%|                return str(clause_index)
   355|        12|            0|            0|  0.00%|        return False
   356|         0|            0|            0|  0.00%|
   357|         0|            0|            0|  0.00%|
   358|         2|            0|            0|  0.00%|    def load_dimacs_string(self, string):
   359|         0|            0|            0|  0.00%|        """Encode a dimacs string and add it to the clause list of this CNF_formula"""
   360|         0|            0|            0|  0.00%|
   361|         2|            0|            0|  0.00%|        clause_counter = len(self.clauses)
   362|         0|            0|            0|  0.00%|        # Every line is a clause
   363|     12014|   0.00900793|  7.49786e-07|  0.05%|        for line in string.splitlines():
   364|         0|            0|            0|  0.00%|
   365|         0|            0|            0|  0.00%|            # Skip the lines starting with p or c
   366|     12012|     0.028024|    2.333e-06|  0.16%|            if line[0] == "p" or line[0] == "c":
   367|         0|            0|            0|  0.00%|                continue
   368|         0|            0|            0|  0.00%|
   369|         0|            0|            0|  0.00%|            # Puts ints in a list. Remove last cause its 0
   370|     12011|    0.0200205|  1.66685e-06|  0.12%|            literals = line.split()[:-1]
   371|         0|            0|            0|  0.00%|
   372|         0|            0|            0|  0.00%|            # Turn all literal strings to literal objects
   373|     12011|    0.0149515|  1.24481e-06|  0.09%|            literal_set = set()
   374|     38278|    0.0642908|  1.67957e-06|  0.38%|            for literal in literals:
   375|         0|            0|            0|  0.00%|
   376|     26267|    0.0290759|  1.10693e-06|  0.17%|                literal = int(literal)
   377|         0|            0|            0|  0.00%|
   378|         0|            0|            0|  0.00%|                # Get (none negated) variable
   379|     26267|    0.0320282|  1.21933e-06|  0.19%|                variable = abs(literal)
   380|         0|            0|            0|  0.00%|
   381|         0|            0|            0|  0.00%|                # If not yet in dict create new dict entry
   382|     26267|    0.0320323|  1.21949e-06|  0.19%|                if str(variable) not in self.variable_dict:
   383|       729|    0.0090282|  1.23844e-05|  0.05%|                    self.variable_dict[str(variable)] = Variable(str(variable))
(call)|       729|   0.00877094|  1.20315e-05|  0.05%|# C:\Users\bdode\Documents\Website_projects\SAT\working_learning\SAT-44\code\classes\CNF.py:505 __init__
   384|         0|            0|            0|  0.00%|
   385|     26267|     0.037044|  1.41029e-06|  0.22%|                literal_set.add(literal)
   386|         0|            0|            0|  0.00%|
   387|         0|            0|            0|  0.00%|                # Update variable counter
   388|     26267|    0.0290034|  1.10418e-06|  0.17%|                if literal < 0:
   389|     23328|    0.0390248|  1.67288e-06|  0.23%|                    self.variable_dict[str(variable)].occurs_negated_in.add(clause_counter)
   390|         0|            0|            0|  0.00%|                else:
   391|      2939|    0.0060041|   2.0429e-06|  0.04%|                    self.variable_dict[str(variable)].occurs_positive_in.add(clause_counter)
   392|         0|            0|            0|  0.00%|
   393|         0|            0|            0|  0.00%|            # Make new clause and append to CNF clause list
   394|     12011|    0.0210204|   1.7501e-06|  0.12%|            self.clauses[str(clause_counter)] = literal_set
   395|     12011|     0.022022|  1.83349e-06|  0.13%|            self.active_clauses.add(clause_counter)
   396|     12011|    0.0170128|  1.41644e-06|  0.10%|            clause_counter += 1
   397|         0|            0|            0|  0.00%|
   398|         0|            0|            0|  0.00%|
   399|         1|            0|            0|  0.00%|    def load_dimacs_file(self, file):
   400|         0|            0|            0|  0.00%|        """Accepts a dimac file and turns it into a string, then uses another method to encode it and add it to the clauses"""
   401|         0|            0|            0|  0.00%|
   402|         0|            0|            0|  0.00%|        # Turn file into string
   403|         1|            0|            0|  0.00%|        with open(file, "r") as dimac:
(call)|         1|            0|            0|  0.00%|# C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.8_3.8.1520.0_x64__qbz5n2kfra8p0\lib\_bootlocale.py:11 getpreferredencoding
(call)|         1|            0|            0|  0.00%|# C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.8_3.8.1520.0_x64__qbz5n2kfra8p0\lib\codecs.py:260 __init__
   404|         1|  0.000975609|  0.000975609|  0.01%|            string = dimac.read()
(call)|         1|            0|            0|  0.00%|# C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.8_3.8.1520.0_x64__qbz5n2kfra8p0\lib\encodings\cp1252.py:22 decode
   405|         0|            0|            0|  0.00%|
   406|         0|            0|            0|  0.00%|        # Add string to clauses
   407|         1|            0|            0|  0.00%|        self.load_dimacs_string(string)
(call)|         1|     0.418362|     0.418362|  2.46%|# C:\Users\bdode\Documents\Website_projects\SAT\working_learning\SAT-44\code\classes\CNF.py:358 load_dimacs_string
   408|         0|            0|            0|  0.00%|
   409|         0|            0|            0|  0.00%|
   410|         1|            0|            0|  0.00%|    def load_sudoku_file(self, mfile):
   411|         0|            0|            0|  0.00%|        # Opens the file, reads the number of sudokus (lines) in it and asks which sudoku you want to solve
   412|         1|            0|            0|  0.00%|        with open(mfile, "r") as sud_file:
(call)|         1|   0.00100088|   0.00100088|  0.01%|# C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.8_3.8.1520.0_x64__qbz5n2kfra8p0\lib\_bootlocale.py:11 getpreferredencoding
(call)|         1|            0|            0|  0.00%|# C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.8_3.8.1520.0_x64__qbz5n2kfra8p0\lib\codecs.py:260 __init__
   413|         1|            0|            0|  0.00%|            nbLines = len(sud_file.readlines())
(call)|        12|            0|            0|  0.00%|# C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.8_3.8.1520.0_x64__qbz5n2kfra8p0\lib\encodings\cp1252.py:22 decode
   414|         1|            0|            0|  0.00%|        print ("Loading file",mfile)
(call)|         4|            0|            0|  0.00%|# C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.8_3.8.1520.0_x64__qbz5n2kfra8p0\lib\encodings\cp1252.py:18 encode
   415|         1|      9.96983|      9.96983| 58.54%|        sudNb = input("{} sudokus have been found in this file.\nWhich one should we solve ?\n".format(nbLines))
(call)|         1|            0|            0|  0.00%|# C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.8_3.8.1520.0_x64__qbz5n2kfra8p0\lib\encodings\cp1252.py:18 encode
(call)|         1|            0|            0|  0.00%|# C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.8_3.8.1520.0_x64__qbz5n2kfra8p0\lib\codecs.py:319 decode
   416|         0|            0|            0|  0.00%|
   417|         0|            0|            0|  0.00%|        # Opens the file to transform the sudoku line into a string in CNF
   418|         1|            0|            0|  0.00%|        line = linecache.getline(mfile, int(sudNb))
(call)|         1|   0.00100112|   0.00100112|  0.01%|# C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.8_3.8.1520.0_x64__qbz5n2kfra8p0\lib\linecache.py:15 getline
   419|         1|            0|            0|  0.00%|        length = math.sqrt(len(line))
   420|         1|            0|            0|  0.00%|        length = (int(round(length)))
   421|         1|            0|            0|  0.00%|        sudtorules = []
   422|        10|            0|            0|  0.00%|        for i in range(length):
   423|        90|            0|            0|  0.00%|            for j in range(length):
   424|        81|            0|            0|  0.00%|                n = line[i*length+j]
   425|        81|            0|            0|  0.00%|                if n!="." :
   426|        23|            0|            0|  0.00%|                    string = ("{}{}{}".format(i+1,j+1,n))
   427|        23|   0.00100064|  4.35062e-05|  0.01%|                    sudtorules.append(string)
   428|         1|            0|            0|  0.00%|        sudoku_dimacs = ""
   429|        24|            0|            0|  0.00%|        for rule in sudtorules:
   430|        23|            0|            0|  0.00%|            sudoku_dimacs = sudoku_dimacs +("{} 0\n".format(rule))
   431|         0|            0|            0|  0.00%|
   432|         0|            0|            0|  0.00%|        # Use this method to encode the dimac file and add it to the CNF
   433|         1|            0|            0|  0.00%|        self.load_dimacs_string(sudoku_dimacs)
(call)|         1|            0|            0|  0.00%|# C:\Users\bdode\Documents\Website_projects\SAT\working_learning\SAT-44\code\classes\CNF.py:358 load_dimacs_string
   434|         0|            0|            0|  0.00%|
   435|         0|            0|            0|  0.00%|    # Prints all clauses of the CNF
   436|         0|            0|            0|  0.00%|    def print_clauses(self):
   437|         0|            0|            0|  0.00%|        print("Clause_id: clause_set : removed_part")
   438|         0|            0|            0|  0.00%|        if not self.clauses:
   439|         0|            0|            0|  0.00%|            print("No clauses left")
   440|         0|            0|            0|  0.00%|            print()
   441|         0|            0|            0|  0.00%|            return
   442|         0|            0|            0|  0.00%|
   443|         0|            0|            0|  0.00%|        for clause_key in range(0, max([int(key) for key in self.clauses.keys()]) + 1):
   444|         0|            0|            0|  0.00%|            value = self.clauses[str(clause_key)]
   445|         0|            0|            0|  0.00%|            if not value:
   446|         0|            0|            0|  0.00%|                if str(clause_key) in self.clauses_removed_part:
   447|         0|            0|            0|  0.00%|                    print(f"{clause_key}: empty clause:      {self.clauses_removed_part[str(clause_key)]}")
   448|         0|            0|            0|  0.00%|                else:
   449|         0|            0|            0|  0.00%|                    print(f"{clause_key}: empty clause")
   450|         0|            0|            0|  0.00%|            else:
   451|         0|            0|            0|  0.00%|                if str(clause_key) in self.clauses_removed_part:
   452|         0|            0|            0|  0.00%|                    print(f"{clause_key}: {value} :        {self.clauses_removed_part[str(clause_key)]}")
   453|         0|            0|            0|  0.00%|                else:
   454|         0|            0|            0|  0.00%|                    print(f"{clause_key}: {value}")
   455|         0|            0|            0|  0.00%|        print()
   456|         0|            0|            0|  0.00%|
   457|         0|            0|            0|  0.00%|
   458|         0|            0|            0|  0.00%|    def print_variable_counts(self):
   459|         0|            0|            0|  0.00%|        """Prints the records of in which clause literals are still located"""
   460|         0|            0|            0|  0.00%|
   461|         0|            0|            0|  0.00%|        print("Variable name, followed by in which clauses it is located negated (-) and positive(+)")
   462|         0|            0|            0|  0.00%|        for variable in sorted(self.variable_dict, key = lambda x: int(x) ):
   463|         0|            0|            0|  0.00%|            print("{} occurs in clauses: -:{}, +:{}".format(self.variable_dict[variable].variable_name, list(self.variable_dict[variable].occurs_negated_in), list(self.variable_dict[variable].occurs_positive_in)))
   464|         0|            0|            0|  0.00%|        print()
   465|         0|            0|            0|  0.00%|
   466|         0|            0|            0|  0.00%|
   467|         0|            0|            0|  0.00%|    def print_status(self):
   468|         0|            0|            0|  0.00%|        """Print the currently loaded variables and clauses"""
   469|         0|            0|            0|  0.00%|
   470|         0|            0|            0|  0.00%|        print(f"Variables: {len(self.variable_dict)}, Clauses: {len(self.active_clauses)}")
   471|         0|            0|            0|  0.00%|        print()
   472|         0|            0|            0|  0.00%|
   473|         0|            0|            0|  0.00%|
   474|         0|            0|            0|  0.00%|    def print_assignments(self):
   475|         0|            0|            0|  0.00%|        for variable in sorted(self.variable_dict, key = lambda x: int(x)):
   476|         0|            0|            0|  0.00%|            print(f"{variable}: {self.variable_dict[variable].boolean}")
   477|         0|            0|            0|  0.00%|            variable = self.variable_dict[variable]
   478|         0|            0|            0|  0.00%|            print(f"     by_branch: {variable.by_branch}     depth: {variable.set_depth}     caused_by: {variable.caused_by_clause_id}")
   479|         0|            0|            0|  0.00%|        print()
   480|         0|            0|            0|  0.00%|
   481|         1|            0|            0|  0.00%|    def print_answer(self):
   482|         1|            0|            0|  0.00%|        print("Sudoku answer: ")
(call)|         2|            0|            0|  0.00%|# C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.8_3.8.1520.0_x64__qbz5n2kfra8p0\lib\encodings\cp1252.py:18 encode
   483|      2188|   0.00400352|  1.82976e-06|  0.02%|        for variable in sorted(self.variable_dict, key = lambda x: int(x)):
(call)|       729|   0.00100183|  1.37426e-06|  0.01%|# C:\Users\bdode\Documents\Website_projects\SAT\working_learning\SAT-44\code\classes\CNF.py:483 <lambda>
   484|       729|            0|            0|  0.00%|            if self.variable_dict[variable].boolean == True:
   485|        81|    0.0010004|  1.23507e-05|  0.01%|                print(f"{variable}: {self.variable_dict[variable].boolean}")
(call)|       162|   0.00100136|  6.18122e-06|  0.01%|# C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.8_3.8.1520.0_x64__qbz5n2kfra8p0\lib\encodings\cp1252.py:18 encode
   486|         1|            0|            0|  0.00%|        print()
(call)|         1|            0|            0|  0.00%|# C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.8_3.8.1520.0_x64__qbz5n2kfra8p0\lib\encodings\cp1252.py:18 encode
   487|         0|            0|            0|  0.00%|
   488|         0|            0|            0|  0.00%|    def print_total_status(self):
   489|         0|            0|            0|  0.00%|
   490|         0|            0|            0|  0.00%|        print("-------------------------------------------------------------")
   491|         0|            0|            0|  0.00%|        print("Depth = {}\n".format(self.current_depth))
   492|         0|            0|            0|  0.00%|        self.print_status()
   493|         0|            0|            0|  0.00%|        self.print_clauses()
   494|         0|            0|            0|  0.00%|        self.print_assignments()
   495|         0|            0|            0|  0.00%|        self.print_variable_counts()
   496|         0|            0|            0|  0.00%|        print("Removed clauses: ", self.removed_clauses)
   497|         0|            0|            0|  0.00%|        print("Removed literals: ", self.removed_literals)
   498|         0|            0|            0|  0.00%|        print(self.branch_history)
   499|         0|            0|            0|  0.00%|        print("-------------------------------------------------------------")
   500|         0|            0|            0|  0.00%|
   501|         0|            0|            0|  0.00%|
   502|         0|            0|            0|  0.00%|class Variable():
   503|         0|            0|            0|  0.00%|    """Represents a variable"""
   504|         0|            0|            0|  0.00%|
   505|       729|   0.00176215|  2.41722e-06|  0.01%|    def __init__(self, name):
   506|         0|            0|            0|  0.00%|        # Name of the variable (e.g. 112)
   507|       729|   0.00299668|  4.11068e-06|  0.02%|        self.variable_name = name
   508|         0|            0|            0|  0.00%|
   509|         0|            0|            0|  0.00%|        # Current boolean status of the variable, starts as None
   510|       729|            0|            0|  0.00%|        self.boolean = None
   511|         0|            0|            0|  0.00%|
   512|         0|            0|            0|  0.00%|        # The clause id's in which this variable is present in negated/positive from
   513|       729|   0.00100088|  1.37295e-06|  0.01%|        self.occurs_negated_in = set()
   514|       729|   0.00300217|   4.1182e-06|  0.02%|        self.occurs_positive_in = set()
   515|         0|            0|            0|  0.00%|
   516|         0|            0|            0|  0.00%|        # Implication graph info
   517|       729|            0|            0|  0.00%|        self.by_branch = None
   518|       729|  9.05991e-06|  1.24279e-08|  0.00%|        self.set_depth = None
   519|       729|            0|            0|  0.00%|        self.caused_by_clause_id = None
   520|         0|            0|            0|  0.00%|
   521|         0|            0|            0|  0.00%|
   522|         0|            0|            0|  0.00%|
   523|         0|            0|            0|  0.00%|if __name__ == "__main__":
   524|         0|            0|            0|  0.00%|    pass
File: C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.8_3.8.1520.0_x64__qbz5n2kfra8p0\lib\encodings\cp1252.py
File duration: 0.00100136s (0.01%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|""" Python Character Mapping Codec cp1252 generated from 'MAPPINGS/VENDORS/MICSFT/WINDOWS/CP1252.TXT' with gencodec.py.
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|"""#"
     4|         0|            0|            0|  0.00%|
     5|         0|            0|            0|  0.00%|import codecs
     6|         0|            0|            0|  0.00%|
     7|         0|            0|            0|  0.00%|### Codec APIs
     8|         0|            0|            0|  0.00%|
     9|         0|            0|            0|  0.00%|class Codec(codecs.Codec):
    10|         0|            0|            0|  0.00%|
    11|         0|            0|            0|  0.00%|    def encode(self,input,errors='strict'):
    12|         0|            0|            0|  0.00%|        return codecs.charmap_encode(input,errors,encoding_table)
    13|         0|            0|            0|  0.00%|
    14|         0|            0|            0|  0.00%|    def decode(self,input,errors='strict'):
    15|         0|            0|            0|  0.00%|        return codecs.charmap_decode(input,errors,decoding_table)
    16|         0|            0|            0|  0.00%|
    17|         0|            0|            0|  0.00%|class IncrementalEncoder(codecs.IncrementalEncoder):
    18|       227|   0.00100136|  4.41127e-06|  0.01%|    def encode(self, input, final=False):
    19|       227|            0|            0|  0.00%|        return codecs.charmap_encode(input,self.errors,encoding_table)[0]
    20|         0|            0|            0|  0.00%|
    21|         0|            0|            0|  0.00%|class IncrementalDecoder(codecs.IncrementalDecoder):
    22|        13|            0|            0|  0.00%|    def decode(self, input, final=False):
    23|        13|            0|            0|  0.00%|        return codecs.charmap_decode(input,self.errors,decoding_table)[0]
    24|         0|            0|            0|  0.00%|
    25|         0|            0|            0|  0.00%|class StreamWriter(Codec,codecs.StreamWriter):
    26|         0|            0|            0|  0.00%|    pass
    27|         0|            0|            0|  0.00%|
    28|         0|            0|            0|  0.00%|class StreamReader(Codec,codecs.StreamReader):
    29|         0|            0|            0|  0.00%|    pass
    30|         0|            0|            0|  0.00%|
    31|         0|            0|            0|  0.00%|### encodings module API
    32|         0|            0|            0|  0.00%|
    33|         0|            0|            0|  0.00%|def getregentry():
    34|         0|            0|            0|  0.00%|    return codecs.CodecInfo(
    35|         0|            0|            0|  0.00%|        name='cp1252',
    36|         0|            0|            0|  0.00%|        encode=Codec().encode,
    37|         0|            0|            0|  0.00%|        decode=Codec().decode,
    38|         0|            0|            0|  0.00%|        incrementalencoder=IncrementalEncoder,
    39|         0|            0|            0|  0.00%|        incrementaldecoder=IncrementalDecoder,
    40|         0|            0|            0|  0.00%|        streamreader=StreamReader,
    41|         0|            0|            0|  0.00%|        streamwriter=StreamWriter,
    42|         0|            0|            0|  0.00%|    )
    43|         0|            0|            0|  0.00%|
    44|         0|            0|            0|  0.00%|
    45|         0|            0|            0|  0.00%|### Decoding Table
    46|         0|            0|            0|  0.00%|
    47|         0|            0|            0|  0.00%|decoding_table = (
    48|         0|            0|            0|  0.00%|    '\x00'     #  0x00 -> NULL
    49|         0|            0|            0|  0.00%|    '\x01'     #  0x01 -> START OF HEADING
    50|         0|            0|            0|  0.00%|    '\x02'     #  0x02 -> START OF TEXT
    51|         0|            0|            0|  0.00%|    '\x03'     #  0x03 -> END OF TEXT
    52|         0|            0|            0|  0.00%|    '\x04'     #  0x04 -> END OF TRANSMISSION
    53|         0|            0|            0|  0.00%|    '\x05'     #  0x05 -> ENQUIRY
    54|         0|            0|            0|  0.00%|    '\x06'     #  0x06 -> ACKNOWLEDGE
    55|         0|            0|            0|  0.00%|    '\x07'     #  0x07 -> BELL
    56|         0|            0|            0|  0.00%|    '\x08'     #  0x08 -> BACKSPACE
    57|         0|            0|            0|  0.00%|    '\t'       #  0x09 -> HORIZONTAL TABULATION
    58|         0|            0|            0|  0.00%|    '\n'       #  0x0A -> LINE FEED
    59|         0|            0|            0|  0.00%|    '\x0b'     #  0x0B -> VERTICAL TABULATION
    60|         0|            0|            0|  0.00%|    '\x0c'     #  0x0C -> FORM FEED
    61|         0|            0|            0|  0.00%|    '\r'       #  0x0D -> CARRIAGE RETURN
    62|         0|            0|            0|  0.00%|    '\x0e'     #  0x0E -> SHIFT OUT
    63|         0|            0|            0|  0.00%|    '\x0f'     #  0x0F -> SHIFT IN
    64|         0|            0|            0|  0.00%|    '\x10'     #  0x10 -> DATA LINK ESCAPE
    65|         0|            0|            0|  0.00%|    '\x11'     #  0x11 -> DEVICE CONTROL ONE
    66|         0|            0|            0|  0.00%|    '\x12'     #  0x12 -> DEVICE CONTROL TWO
    67|         0|            0|            0|  0.00%|    '\x13'     #  0x13 -> DEVICE CONTROL THREE
    68|         0|            0|            0|  0.00%|    '\x14'     #  0x14 -> DEVICE CONTROL FOUR
    69|         0|            0|            0|  0.00%|    '\x15'     #  0x15 -> NEGATIVE ACKNOWLEDGE
    70|         0|            0|            0|  0.00%|    '\x16'     #  0x16 -> SYNCHRONOUS IDLE
    71|         0|            0|            0|  0.00%|    '\x17'     #  0x17 -> END OF TRANSMISSION BLOCK
    72|         0|            0|            0|  0.00%|    '\x18'     #  0x18 -> CANCEL
    73|         0|            0|            0|  0.00%|    '\x19'     #  0x19 -> END OF MEDIUM
    74|         0|            0|            0|  0.00%|    '\x1a'     #  0x1A -> SUBSTITUTE
    75|         0|            0|            0|  0.00%|    '\x1b'     #  0x1B -> ESCAPE
    76|         0|            0|            0|  0.00%|    '\x1c'     #  0x1C -> FILE SEPARATOR
    77|         0|            0|            0|  0.00%|    '\x1d'     #  0x1D -> GROUP SEPARATOR
    78|         0|            0|            0|  0.00%|    '\x1e'     #  0x1E -> RECORD SEPARATOR
    79|         0|            0|            0|  0.00%|    '\x1f'     #  0x1F -> UNIT SEPARATOR
    80|         0|            0|            0|  0.00%|    ' '        #  0x20 -> SPACE
    81|         0|            0|            0|  0.00%|    '!'        #  0x21 -> EXCLAMATION MARK
    82|         0|            0|            0|  0.00%|    '"'        #  0x22 -> QUOTATION MARK
    83|         0|            0|            0|  0.00%|    '#'        #  0x23 -> NUMBER SIGN
    84|         0|            0|            0|  0.00%|    '$'        #  0x24 -> DOLLAR SIGN
    85|         0|            0|            0|  0.00%|    '%'        #  0x25 -> PERCENT SIGN
    86|         0|            0|            0|  0.00%|    '&'        #  0x26 -> AMPERSAND
    87|         0|            0|            0|  0.00%|    "'"        #  0x27 -> APOSTROPHE
    88|         0|            0|            0|  0.00%|    '('        #  0x28 -> LEFT PARENTHESIS
    89|         0|            0|            0|  0.00%|    ')'        #  0x29 -> RIGHT PARENTHESIS
    90|         0|            0|            0|  0.00%|    '*'        #  0x2A -> ASTERISK
    91|         0|            0|            0|  0.00%|    '+'        #  0x2B -> PLUS SIGN
    92|         0|            0|            0|  0.00%|    ','        #  0x2C -> COMMA
    93|         0|            0|            0|  0.00%|    '-'        #  0x2D -> HYPHEN-MINUS
    94|         0|            0|            0|  0.00%|    '.'        #  0x2E -> FULL STOP
    95|         0|            0|            0|  0.00%|    '/'        #  0x2F -> SOLIDUS
    96|         0|            0|            0|  0.00%|    '0'        #  0x30 -> DIGIT ZERO
    97|         0|            0|            0|  0.00%|    '1'        #  0x31 -> DIGIT ONE
    98|         0|            0|            0|  0.00%|    '2'        #  0x32 -> DIGIT TWO
    99|         0|            0|            0|  0.00%|    '3'        #  0x33 -> DIGIT THREE
   100|         0|            0|            0|  0.00%|    '4'        #  0x34 -> DIGIT FOUR
   101|         0|            0|            0|  0.00%|    '5'        #  0x35 -> DIGIT FIVE
   102|         0|            0|            0|  0.00%|    '6'        #  0x36 -> DIGIT SIX
   103|         0|            0|            0|  0.00%|    '7'        #  0x37 -> DIGIT SEVEN
   104|         0|            0|            0|  0.00%|    '8'        #  0x38 -> DIGIT EIGHT
   105|         0|            0|            0|  0.00%|    '9'        #  0x39 -> DIGIT NINE
   106|         0|            0|            0|  0.00%|    ':'        #  0x3A -> COLON
   107|         0|            0|            0|  0.00%|    ';'        #  0x3B -> SEMICOLON
   108|         0|            0|            0|  0.00%|    '<'        #  0x3C -> LESS-THAN SIGN
   109|         0|            0|            0|  0.00%|    '='        #  0x3D -> EQUALS SIGN
   110|         0|            0|            0|  0.00%|    '>'        #  0x3E -> GREATER-THAN SIGN
   111|         0|            0|            0|  0.00%|    '?'        #  0x3F -> QUESTION MARK
   112|         0|            0|            0|  0.00%|    '@'        #  0x40 -> COMMERCIAL AT
   113|         0|            0|            0|  0.00%|    'A'        #  0x41 -> LATIN CAPITAL LETTER A
   114|         0|            0|            0|  0.00%|    'B'        #  0x42 -> LATIN CAPITAL LETTER B
   115|         0|            0|            0|  0.00%|    'C'        #  0x43 -> LATIN CAPITAL LETTER C
   116|         0|            0|            0|  0.00%|    'D'        #  0x44 -> LATIN CAPITAL LETTER D
   117|         0|            0|            0|  0.00%|    'E'        #  0x45 -> LATIN CAPITAL LETTER E
   118|         0|            0|            0|  0.00%|    'F'        #  0x46 -> LATIN CAPITAL LETTER F
   119|         0|            0|            0|  0.00%|    'G'        #  0x47 -> LATIN CAPITAL LETTER G
   120|         0|            0|            0|  0.00%|    'H'        #  0x48 -> LATIN CAPITAL LETTER H
   121|         0|            0|            0|  0.00%|    'I'        #  0x49 -> LATIN CAPITAL LETTER I
   122|         0|            0|            0|  0.00%|    'J'        #  0x4A -> LATIN CAPITAL LETTER J
   123|         0|            0|            0|  0.00%|    'K'        #  0x4B -> LATIN CAPITAL LETTER K
   124|         0|            0|            0|  0.00%|    'L'        #  0x4C -> LATIN CAPITAL LETTER L
   125|         0|            0|            0|  0.00%|    'M'        #  0x4D -> LATIN CAPITAL LETTER M
   126|         0|            0|            0|  0.00%|    'N'        #  0x4E -> LATIN CAPITAL LETTER N
   127|         0|            0|            0|  0.00%|    'O'        #  0x4F -> LATIN CAPITAL LETTER O
   128|         0|            0|            0|  0.00%|    'P'        #  0x50 -> LATIN CAPITAL LETTER P
   129|         0|            0|            0|  0.00%|    'Q'        #  0x51 -> LATIN CAPITAL LETTER Q
   130|         0|            0|            0|  0.00%|    'R'        #  0x52 -> LATIN CAPITAL LETTER R
   131|         0|            0|            0|  0.00%|    'S'        #  0x53 -> LATIN CAPITAL LETTER S
   132|         0|            0|            0|  0.00%|    'T'        #  0x54 -> LATIN CAPITAL LETTER T
   133|         0|            0|            0|  0.00%|    'U'        #  0x55 -> LATIN CAPITAL LETTER U
   134|         0|            0|            0|  0.00%|    'V'        #  0x56 -> LATIN CAPITAL LETTER V
   135|         0|            0|            0|  0.00%|    'W'        #  0x57 -> LATIN CAPITAL LETTER W
   136|         0|            0|            0|  0.00%|    'X'        #  0x58 -> LATIN CAPITAL LETTER X
   137|         0|            0|            0|  0.00%|    'Y'        #  0x59 -> LATIN CAPITAL LETTER Y
   138|         0|            0|            0|  0.00%|    'Z'        #  0x5A -> LATIN CAPITAL LETTER Z
   139|         0|            0|            0|  0.00%|    '['        #  0x5B -> LEFT SQUARE BRACKET
   140|         0|            0|            0|  0.00%|    '\\'       #  0x5C -> REVERSE SOLIDUS
   141|         0|            0|            0|  0.00%|    ']'        #  0x5D -> RIGHT SQUARE BRACKET
   142|         0|            0|            0|  0.00%|    '^'        #  0x5E -> CIRCUMFLEX ACCENT
   143|         0|            0|            0|  0.00%|    '_'        #  0x5F -> LOW LINE
   144|         0|            0|            0|  0.00%|    '`'        #  0x60 -> GRAVE ACCENT
   145|         0|            0|            0|  0.00%|    'a'        #  0x61 -> LATIN SMALL LETTER A
   146|         0|            0|            0|  0.00%|    'b'        #  0x62 -> LATIN SMALL LETTER B
   147|         0|            0|            0|  0.00%|    'c'        #  0x63 -> LATIN SMALL LETTER C
   148|         0|            0|            0|  0.00%|    'd'        #  0x64 -> LATIN SMALL LETTER D
   149|         0|            0|            0|  0.00%|    'e'        #  0x65 -> LATIN SMALL LETTER E
   150|         0|            0|            0|  0.00%|    'f'        #  0x66 -> LATIN SMALL LETTER F
   151|         0|            0|            0|  0.00%|    'g'        #  0x67 -> LATIN SMALL LETTER G
   152|         0|            0|            0|  0.00%|    'h'        #  0x68 -> LATIN SMALL LETTER H
   153|         0|            0|            0|  0.00%|    'i'        #  0x69 -> LATIN SMALL LETTER I
   154|         0|            0|            0|  0.00%|    'j'        #  0x6A -> LATIN SMALL LETTER J
   155|         0|            0|            0|  0.00%|    'k'        #  0x6B -> LATIN SMALL LETTER K
   156|         0|            0|            0|  0.00%|    'l'        #  0x6C -> LATIN SMALL LETTER L
   157|         0|            0|            0|  0.00%|    'm'        #  0x6D -> LATIN SMALL LETTER M
   158|         0|            0|            0|  0.00%|    'n'        #  0x6E -> LATIN SMALL LETTER N
   159|         0|            0|            0|  0.00%|    'o'        #  0x6F -> LATIN SMALL LETTER O
   160|         0|            0|            0|  0.00%|    'p'        #  0x70 -> LATIN SMALL LETTER P
   161|         0|            0|            0|  0.00%|    'q'        #  0x71 -> LATIN SMALL LETTER Q
   162|         0|            0|            0|  0.00%|    'r'        #  0x72 -> LATIN SMALL LETTER R
   163|         0|            0|            0|  0.00%|    's'        #  0x73 -> LATIN SMALL LETTER S
   164|         0|            0|            0|  0.00%|    't'        #  0x74 -> LATIN SMALL LETTER T
   165|         0|            0|            0|  0.00%|    'u'        #  0x75 -> LATIN SMALL LETTER U
   166|         0|            0|            0|  0.00%|    'v'        #  0x76 -> LATIN SMALL LETTER V
   167|         0|            0|            0|  0.00%|    'w'        #  0x77 -> LATIN SMALL LETTER W
   168|         0|            0|            0|  0.00%|    'x'        #  0x78 -> LATIN SMALL LETTER X
   169|         0|            0|            0|  0.00%|    'y'        #  0x79 -> LATIN SMALL LETTER Y
   170|         0|            0|            0|  0.00%|    'z'        #  0x7A -> LATIN SMALL LETTER Z
   171|         0|            0|            0|  0.00%|    '{'        #  0x7B -> LEFT CURLY BRACKET
   172|         0|            0|            0|  0.00%|    '|'        #  0x7C -> VERTICAL LINE
   173|         0|            0|            0|  0.00%|    '}'        #  0x7D -> RIGHT CURLY BRACKET
   174|         0|            0|            0|  0.00%|    '~'        #  0x7E -> TILDE
   175|         0|            0|            0|  0.00%|    '\x7f'     #  0x7F -> DELETE
   176|         0|            0|            0|  0.00%|    '\u20ac'   #  0x80 -> EURO SIGN
   177|         0|            0|            0|  0.00%|    '\ufffe'   #  0x81 -> UNDEFINED
   178|         0|            0|            0|  0.00%|    '\u201a'   #  0x82 -> SINGLE LOW-9 QUOTATION MARK
   179|         0|            0|            0|  0.00%|    '\u0192'   #  0x83 -> LATIN SMALL LETTER F WITH HOOK
   180|         0|            0|            0|  0.00%|    '\u201e'   #  0x84 -> DOUBLE LOW-9 QUOTATION MARK
   181|         0|            0|            0|  0.00%|    '\u2026'   #  0x85 -> HORIZONTAL ELLIPSIS
   182|         0|            0|            0|  0.00%|    '\u2020'   #  0x86 -> DAGGER
   183|         0|            0|            0|  0.00%|    '\u2021'   #  0x87 -> DOUBLE DAGGER
   184|         0|            0|            0|  0.00%|    '\u02c6'   #  0x88 -> MODIFIER LETTER CIRCUMFLEX ACCENT
   185|         0|            0|            0|  0.00%|    '\u2030'   #  0x89 -> PER MILLE SIGN
   186|         0|            0|            0|  0.00%|    '\u0160'   #  0x8A -> LATIN CAPITAL LETTER S WITH CARON
   187|         0|            0|            0|  0.00%|    '\u2039'   #  0x8B -> SINGLE LEFT-POINTING ANGLE QUOTATION MARK
   188|         0|            0|            0|  0.00%|    '\u0152'   #  0x8C -> LATIN CAPITAL LIGATURE OE
   189|         0|            0|            0|  0.00%|    '\ufffe'   #  0x8D -> UNDEFINED
   190|         0|            0|            0|  0.00%|    '\u017d'   #  0x8E -> LATIN CAPITAL LETTER Z WITH CARON
   191|         0|            0|            0|  0.00%|    '\ufffe'   #  0x8F -> UNDEFINED
   192|         0|            0|            0|  0.00%|    '\ufffe'   #  0x90 -> UNDEFINED
   193|         0|            0|            0|  0.00%|    '\u2018'   #  0x91 -> LEFT SINGLE QUOTATION MARK
   194|         0|            0|            0|  0.00%|    '\u2019'   #  0x92 -> RIGHT SINGLE QUOTATION MARK
   195|         0|            0|            0|  0.00%|    '\u201c'   #  0x93 -> LEFT DOUBLE QUOTATION MARK
   196|         0|            0|            0|  0.00%|    '\u201d'   #  0x94 -> RIGHT DOUBLE QUOTATION MARK
   197|         0|            0|            0|  0.00%|    '\u2022'   #  0x95 -> BULLET
   198|         0|            0|            0|  0.00%|    '\u2013'   #  0x96 -> EN DASH
   199|         0|            0|            0|  0.00%|    '\u2014'   #  0x97 -> EM DASH
   200|         0|            0|            0|  0.00%|    '\u02dc'   #  0x98 -> SMALL TILDE
   201|         0|            0|            0|  0.00%|    '\u2122'   #  0x99 -> TRADE MARK SIGN
   202|         0|            0|            0|  0.00%|    '\u0161'   #  0x9A -> LATIN SMALL LETTER S WITH CARON
   203|         0|            0|            0|  0.00%|    '\u203a'   #  0x9B -> SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
   204|         0|            0|            0|  0.00%|    '\u0153'   #  0x9C -> LATIN SMALL LIGATURE OE
   205|         0|            0|            0|  0.00%|    '\ufffe'   #  0x9D -> UNDEFINED
   206|         0|            0|            0|  0.00%|    '\u017e'   #  0x9E -> LATIN SMALL LETTER Z WITH CARON
   207|         0|            0|            0|  0.00%|    '\u0178'   #  0x9F -> LATIN CAPITAL LETTER Y WITH DIAERESIS
   208|         0|            0|            0|  0.00%|    '\xa0'     #  0xA0 -> NO-BREAK SPACE
   209|         0|            0|            0|  0.00%|    '\xa1'     #  0xA1 -> INVERTED EXCLAMATION MARK
   210|         0|            0|            0|  0.00%|    '\xa2'     #  0xA2 -> CENT SIGN
   211|         0|            0|            0|  0.00%|    '\xa3'     #  0xA3 -> POUND SIGN
   212|         0|            0|            0|  0.00%|    '\xa4'     #  0xA4 -> CURRENCY SIGN
   213|         0|            0|            0|  0.00%|    '\xa5'     #  0xA5 -> YEN SIGN
   214|         0|            0|            0|  0.00%|    '\xa6'     #  0xA6 -> BROKEN BAR
   215|         0|            0|            0|  0.00%|    '\xa7'     #  0xA7 -> SECTION SIGN
   216|         0|            0|            0|  0.00%|    '\xa8'     #  0xA8 -> DIAERESIS
   217|         0|            0|            0|  0.00%|    '\xa9'     #  0xA9 -> COPYRIGHT SIGN
   218|         0|            0|            0|  0.00%|    '\xaa'     #  0xAA -> FEMININE ORDINAL INDICATOR
   219|         0|            0|            0|  0.00%|    '\xab'     #  0xAB -> LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
   220|         0|            0|            0|  0.00%|    '\xac'     #  0xAC -> NOT SIGN
   221|         0|            0|            0|  0.00%|    '\xad'     #  0xAD -> SOFT HYPHEN
   222|         0|            0|            0|  0.00%|    '\xae'     #  0xAE -> REGISTERED SIGN
   223|         0|            0|            0|  0.00%|    '\xaf'     #  0xAF -> MACRON
   224|         0|            0|            0|  0.00%|    '\xb0'     #  0xB0 -> DEGREE SIGN
   225|         0|            0|            0|  0.00%|    '\xb1'     #  0xB1 -> PLUS-MINUS SIGN
   226|         0|            0|            0|  0.00%|    '\xb2'     #  0xB2 -> SUPERSCRIPT TWO
   227|         0|            0|            0|  0.00%|    '\xb3'     #  0xB3 -> SUPERSCRIPT THREE
   228|         0|            0|            0|  0.00%|    '\xb4'     #  0xB4 -> ACUTE ACCENT
   229|         0|            0|            0|  0.00%|    '\xb5'     #  0xB5 -> MICRO SIGN
   230|         0|            0|            0|  0.00%|    '\xb6'     #  0xB6 -> PILCROW SIGN
   231|         0|            0|            0|  0.00%|    '\xb7'     #  0xB7 -> MIDDLE DOT
   232|         0|            0|            0|  0.00%|    '\xb8'     #  0xB8 -> CEDILLA
   233|         0|            0|            0|  0.00%|    '\xb9'     #  0xB9 -> SUPERSCRIPT ONE
   234|         0|            0|            0|  0.00%|    '\xba'     #  0xBA -> MASCULINE ORDINAL INDICATOR
   235|         0|            0|            0|  0.00%|    '\xbb'     #  0xBB -> RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
   236|         0|            0|            0|  0.00%|    '\xbc'     #  0xBC -> VULGAR FRACTION ONE QUARTER
   237|         0|            0|            0|  0.00%|    '\xbd'     #  0xBD -> VULGAR FRACTION ONE HALF
   238|         0|            0|            0|  0.00%|    '\xbe'     #  0xBE -> VULGAR FRACTION THREE QUARTERS
   239|         0|            0|            0|  0.00%|    '\xbf'     #  0xBF -> INVERTED QUESTION MARK
   240|         0|            0|            0|  0.00%|    '\xc0'     #  0xC0 -> LATIN CAPITAL LETTER A WITH GRAVE
   241|         0|            0|            0|  0.00%|    '\xc1'     #  0xC1 -> LATIN CAPITAL LETTER A WITH ACUTE
   242|         0|            0|            0|  0.00%|    '\xc2'     #  0xC2 -> LATIN CAPITAL LETTER A WITH CIRCUMFLEX
   243|         0|            0|            0|  0.00%|    '\xc3'     #  0xC3 -> LATIN CAPITAL LETTER A WITH TILDE
   244|         0|            0|            0|  0.00%|    '\xc4'     #  0xC4 -> LATIN CAPITAL LETTER A WITH DIAERESIS
   245|         0|            0|            0|  0.00%|    '\xc5'     #  0xC5 -> LATIN CAPITAL LETTER A WITH RING ABOVE
   246|         0|            0|            0|  0.00%|    '\xc6'     #  0xC6 -> LATIN CAPITAL LETTER AE
   247|         0|            0|            0|  0.00%|    '\xc7'     #  0xC7 -> LATIN CAPITAL LETTER C WITH CEDILLA
   248|         0|            0|            0|  0.00%|    '\xc8'     #  0xC8 -> LATIN CAPITAL LETTER E WITH GRAVE
   249|         0|            0|            0|  0.00%|    '\xc9'     #  0xC9 -> LATIN CAPITAL LETTER E WITH ACUTE
   250|         0|            0|            0|  0.00%|    '\xca'     #  0xCA -> LATIN CAPITAL LETTER E WITH CIRCUMFLEX
   251|         0|            0|            0|  0.00%|    '\xcb'     #  0xCB -> LATIN CAPITAL LETTER E WITH DIAERESIS
   252|         0|            0|            0|  0.00%|    '\xcc'     #  0xCC -> LATIN CAPITAL LETTER I WITH GRAVE
   253|         0|            0|            0|  0.00%|    '\xcd'     #  0xCD -> LATIN CAPITAL LETTER I WITH ACUTE
   254|         0|            0|            0|  0.00%|    '\xce'     #  0xCE -> LATIN CAPITAL LETTER I WITH CIRCUMFLEX
   255|         0|            0|            0|  0.00%|    '\xcf'     #  0xCF -> LATIN CAPITAL LETTER I WITH DIAERESIS
   256|         0|            0|            0|  0.00%|    '\xd0'     #  0xD0 -> LATIN CAPITAL LETTER ETH
   257|         0|            0|            0|  0.00%|    '\xd1'     #  0xD1 -> LATIN CAPITAL LETTER N WITH TILDE
   258|         0|            0|            0|  0.00%|    '\xd2'     #  0xD2 -> LATIN CAPITAL LETTER O WITH GRAVE
   259|         0|            0|            0|  0.00%|    '\xd3'     #  0xD3 -> LATIN CAPITAL LETTER O WITH ACUTE
   260|         0|            0|            0|  0.00%|    '\xd4'     #  0xD4 -> LATIN CAPITAL LETTER O WITH CIRCUMFLEX
   261|         0|            0|            0|  0.00%|    '\xd5'     #  0xD5 -> LATIN CAPITAL LETTER O WITH TILDE
   262|         0|            0|            0|  0.00%|    '\xd6'     #  0xD6 -> LATIN CAPITAL LETTER O WITH DIAERESIS
   263|         0|            0|            0|  0.00%|    '\xd7'     #  0xD7 -> MULTIPLICATION SIGN
   264|         0|            0|            0|  0.00%|    '\xd8'     #  0xD8 -> LATIN CAPITAL LETTER O WITH STROKE
   265|         0|            0|            0|  0.00%|    '\xd9'     #  0xD9 -> LATIN CAPITAL LETTER U WITH GRAVE
   266|         0|            0|            0|  0.00%|    '\xda'     #  0xDA -> LATIN CAPITAL LETTER U WITH ACUTE
   267|         0|            0|            0|  0.00%|    '\xdb'     #  0xDB -> LATIN CAPITAL LETTER U WITH CIRCUMFLEX
   268|         0|            0|            0|  0.00%|    '\xdc'     #  0xDC -> LATIN CAPITAL LETTER U WITH DIAERESIS
   269|         0|            0|            0|  0.00%|    '\xdd'     #  0xDD -> LATIN CAPITAL LETTER Y WITH ACUTE
   270|         0|            0|            0|  0.00%|    '\xde'     #  0xDE -> LATIN CAPITAL LETTER THORN
   271|         0|            0|            0|  0.00%|    '\xdf'     #  0xDF -> LATIN SMALL LETTER SHARP S
   272|         0|            0|            0|  0.00%|    '\xe0'     #  0xE0 -> LATIN SMALL LETTER A WITH GRAVE
   273|         0|            0|            0|  0.00%|    '\xe1'     #  0xE1 -> LATIN SMALL LETTER A WITH ACUTE
   274|         0|            0|            0|  0.00%|    '\xe2'     #  0xE2 -> LATIN SMALL LETTER A WITH CIRCUMFLEX
   275|         0|            0|            0|  0.00%|    '\xe3'     #  0xE3 -> LATIN SMALL LETTER A WITH TILDE
   276|         0|            0|            0|  0.00%|    '\xe4'     #  0xE4 -> LATIN SMALL LETTER A WITH DIAERESIS
   277|         0|            0|            0|  0.00%|    '\xe5'     #  0xE5 -> LATIN SMALL LETTER A WITH RING ABOVE
   278|         0|            0|            0|  0.00%|    '\xe6'     #  0xE6 -> LATIN SMALL LETTER AE
   279|         0|            0|            0|  0.00%|    '\xe7'     #  0xE7 -> LATIN SMALL LETTER C WITH CEDILLA
   280|         0|            0|            0|  0.00%|    '\xe8'     #  0xE8 -> LATIN SMALL LETTER E WITH GRAVE
   281|         0|            0|            0|  0.00%|    '\xe9'     #  0xE9 -> LATIN SMALL LETTER E WITH ACUTE
   282|         0|            0|            0|  0.00%|    '\xea'     #  0xEA -> LATIN SMALL LETTER E WITH CIRCUMFLEX
   283|         0|            0|            0|  0.00%|    '\xeb'     #  0xEB -> LATIN SMALL LETTER E WITH DIAERESIS
   284|         0|            0|            0|  0.00%|    '\xec'     #  0xEC -> LATIN SMALL LETTER I WITH GRAVE
   285|         0|            0|            0|  0.00%|    '\xed'     #  0xED -> LATIN SMALL LETTER I WITH ACUTE
   286|         0|            0|            0|  0.00%|    '\xee'     #  0xEE -> LATIN SMALL LETTER I WITH CIRCUMFLEX
   287|         0|            0|            0|  0.00%|    '\xef'     #  0xEF -> LATIN SMALL LETTER I WITH DIAERESIS
   288|         0|            0|            0|  0.00%|    '\xf0'     #  0xF0 -> LATIN SMALL LETTER ETH
   289|         0|            0|            0|  0.00%|    '\xf1'     #  0xF1 -> LATIN SMALL LETTER N WITH TILDE
   290|         0|            0|            0|  0.00%|    '\xf2'     #  0xF2 -> LATIN SMALL LETTER O WITH GRAVE
   291|         0|            0|            0|  0.00%|    '\xf3'     #  0xF3 -> LATIN SMALL LETTER O WITH ACUTE
   292|         0|            0|            0|  0.00%|    '\xf4'     #  0xF4 -> LATIN SMALL LETTER O WITH CIRCUMFLEX
   293|         0|            0|            0|  0.00%|    '\xf5'     #  0xF5 -> LATIN SMALL LETTER O WITH TILDE
   294|         0|            0|            0|  0.00%|    '\xf6'     #  0xF6 -> LATIN SMALL LETTER O WITH DIAERESIS
   295|         0|            0|            0|  0.00%|    '\xf7'     #  0xF7 -> DIVISION SIGN
   296|         0|            0|            0|  0.00%|    '\xf8'     #  0xF8 -> LATIN SMALL LETTER O WITH STROKE
   297|         0|            0|            0|  0.00%|    '\xf9'     #  0xF9 -> LATIN SMALL LETTER U WITH GRAVE
   298|         0|            0|            0|  0.00%|    '\xfa'     #  0xFA -> LATIN SMALL LETTER U WITH ACUTE
   299|         0|            0|            0|  0.00%|    '\xfb'     #  0xFB -> LATIN SMALL LETTER U WITH CIRCUMFLEX
   300|         0|            0|            0|  0.00%|    '\xfc'     #  0xFC -> LATIN SMALL LETTER U WITH DIAERESIS
   301|         0|            0|            0|  0.00%|    '\xfd'     #  0xFD -> LATIN SMALL LETTER Y WITH ACUTE
   302|         0|            0|            0|  0.00%|    '\xfe'     #  0xFE -> LATIN SMALL LETTER THORN
   303|         0|            0|            0|  0.00%|    '\xff'     #  0xFF -> LATIN SMALL LETTER Y WITH DIAERESIS
   304|         0|            0|            0|  0.00%|)
   305|         0|            0|            0|  0.00%|
   306|         0|            0|            0|  0.00%|### Encoding table
   307|         0|            0|            0|  0.00%|encoding_table=codecs.charmap_build(decoding_table)
File: C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.8_3.8.1520.0_x64__qbz5n2kfra8p0\lib\tokenize.py
File duration: 0.00100112s (0.01%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""Tokenization help for Python programs.
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|tokenize(readline) is a generator that breaks a stream of bytes into
     4|         0|            0|            0|  0.00%|Python tokens.  It decodes the bytes according to PEP-0263 for
     5|         0|            0|            0|  0.00%|determining source file encoding.
     6|         0|            0|            0|  0.00%|
     7|         0|            0|            0|  0.00%|It accepts a readline-like method which is called repeatedly to get the
     8|         0|            0|            0|  0.00%|next line of input (or b"" for EOF).  It generates 5-tuples with these
     9|         0|            0|            0|  0.00%|members:
    10|         0|            0|            0|  0.00%|
    11|         0|            0|            0|  0.00%|    the token type (see token.py)
    12|         0|            0|            0|  0.00%|    the token (a string)
    13|         0|            0|            0|  0.00%|    the starting (row, column) indices of the token (a 2-tuple of ints)
    14|         0|            0|            0|  0.00%|    the ending (row, column) indices of the token (a 2-tuple of ints)
    15|         0|            0|            0|  0.00%|    the original line (string)
    16|         0|            0|            0|  0.00%|
    17|         0|            0|            0|  0.00%|It is designed to match the working of the Python tokenizer exactly, except
    18|         0|            0|            0|  0.00%|that it produces COMMENT tokens for comments and gives type OP for all
    19|         0|            0|            0|  0.00%|operators.  Additionally, all token lists start with an ENCODING token
    20|         0|            0|            0|  0.00%|which tells you which encoding was used to decode the bytes stream.
    21|         0|            0|            0|  0.00%|"""
    22|         0|            0|            0|  0.00%|
    23|         0|            0|            0|  0.00%|__author__ = 'Ka-Ping Yee <ping@lfw.org>'
    24|         0|            0|            0|  0.00%|__credits__ = ('GvR, ESR, Tim Peters, Thomas Wouters, Fred Drake, '
    25|         0|            0|            0|  0.00%|               'Skip Montanaro, Raymond Hettinger, Trent Nelson, '
    26|         0|            0|            0|  0.00%|               'Michael Foord')
    27|         0|            0|            0|  0.00%|from builtins import open as _builtin_open
    28|         0|            0|            0|  0.00%|from codecs import lookup, BOM_UTF8
    29|         0|            0|            0|  0.00%|import collections
    30|         0|            0|            0|  0.00%|from io import TextIOWrapper
    31|         0|            0|            0|  0.00%|import itertools as _itertools
    32|         0|            0|            0|  0.00%|import re
    33|         0|            0|            0|  0.00%|import sys
    34|         0|            0|            0|  0.00%|from token import *
    35|         0|            0|            0|  0.00%|from token import EXACT_TOKEN_TYPES
    36|         0|            0|            0|  0.00%|
    37|         0|            0|            0|  0.00%|cookie_re = re.compile(r'^[ \t\f]*#.*?coding[:=][ \t]*([-\w.]+)', re.ASCII)
    38|         0|            0|            0|  0.00%|blank_re = re.compile(br'^[ \t\f]*(?:[#\r\n]|$)', re.ASCII)
    39|         0|            0|            0|  0.00%|
    40|         0|            0|            0|  0.00%|import token
    41|         0|            0|            0|  0.00%|__all__ = token.__all__ + ["tokenize", "generate_tokens", "detect_encoding",
    42|         0|            0|            0|  0.00%|                           "untokenize", "TokenInfo"]
    43|         0|            0|            0|  0.00%|del token
    44|         0|            0|            0|  0.00%|
    45|         0|            0|            0|  0.00%|class TokenInfo(collections.namedtuple('TokenInfo', 'type string start end line')):
    46|         0|            0|            0|  0.00%|    def __repr__(self):
    47|         0|            0|            0|  0.00%|        annotated_type = '%d (%s)' % (self.type, tok_name[self.type])
    48|         0|            0|            0|  0.00%|        return ('TokenInfo(type=%s, string=%r, start=%r, end=%r, line=%r)' %
    49|         0|            0|            0|  0.00%|                self._replace(type=annotated_type))
    50|         0|            0|            0|  0.00%|
    51|         0|            0|            0|  0.00%|    @property
    52|         0|            0|            0|  0.00%|    def exact_type(self):
    53|         0|            0|            0|  0.00%|        if self.type == OP and self.string in EXACT_TOKEN_TYPES:
    54|         0|            0|            0|  0.00%|            return EXACT_TOKEN_TYPES[self.string]
    55|         0|            0|            0|  0.00%|        else:
    56|         0|            0|            0|  0.00%|            return self.type
    57|         0|            0|            0|  0.00%|
    58|         0|            0|            0|  0.00%|def group(*choices): return '(' + '|'.join(choices) + ')'
    59|         0|            0|            0|  0.00%|def any(*choices): return group(*choices) + '*'
    60|         0|            0|            0|  0.00%|def maybe(*choices): return group(*choices) + '?'
    61|         0|            0|            0|  0.00%|
    62|         0|            0|            0|  0.00%|# Note: we use unicode matching for names ("\w") but ascii matching for
    63|         0|            0|            0|  0.00%|# number literals.
    64|         0|            0|            0|  0.00%|Whitespace = r'[ \f\t]*'
    65|         0|            0|            0|  0.00%|Comment = r'#[^\r\n]*'
    66|         0|            0|            0|  0.00%|Ignore = Whitespace + any(r'\\\r?\n' + Whitespace) + maybe(Comment)
    67|         0|            0|            0|  0.00%|Name = r'\w+'
    68|         0|            0|            0|  0.00%|
    69|         0|            0|            0|  0.00%|Hexnumber = r'0[xX](?:_?[0-9a-fA-F])+'
    70|         0|            0|            0|  0.00%|Binnumber = r'0[bB](?:_?[01])+'
    71|         0|            0|            0|  0.00%|Octnumber = r'0[oO](?:_?[0-7])+'
    72|         0|            0|            0|  0.00%|Decnumber = r'(?:0(?:_?0)*|[1-9](?:_?[0-9])*)'
    73|         0|            0|            0|  0.00%|Intnumber = group(Hexnumber, Binnumber, Octnumber, Decnumber)
    74|         0|            0|            0|  0.00%|Exponent = r'[eE][-+]?[0-9](?:_?[0-9])*'
    75|         0|            0|            0|  0.00%|Pointfloat = group(r'[0-9](?:_?[0-9])*\.(?:[0-9](?:_?[0-9])*)?',
    76|         0|            0|            0|  0.00%|                   r'\.[0-9](?:_?[0-9])*') + maybe(Exponent)
    77|         0|            0|            0|  0.00%|Expfloat = r'[0-9](?:_?[0-9])*' + Exponent
    78|         0|            0|            0|  0.00%|Floatnumber = group(Pointfloat, Expfloat)
    79|         0|            0|            0|  0.00%|Imagnumber = group(r'[0-9](?:_?[0-9])*[jJ]', Floatnumber + r'[jJ]')
    80|         0|            0|            0|  0.00%|Number = group(Imagnumber, Floatnumber, Intnumber)
    81|         0|            0|            0|  0.00%|
    82|         0|            0|            0|  0.00%|# Return the empty string, plus all of the valid string prefixes.
    83|         0|            0|            0|  0.00%|def _all_string_prefixes():
    84|         0|            0|            0|  0.00%|    # The valid string prefixes. Only contain the lower case versions,
    85|         0|            0|            0|  0.00%|    #  and don't contain any permutations (include 'fr', but not
    86|         0|            0|            0|  0.00%|    #  'rf'). The various permutations will be generated.
    87|         0|            0|            0|  0.00%|    _valid_string_prefixes = ['b', 'r', 'u', 'f', 'br', 'fr']
    88|         0|            0|            0|  0.00%|    # if we add binary f-strings, add: ['fb', 'fbr']
    89|         0|            0|            0|  0.00%|    result = {''}
    90|         0|            0|            0|  0.00%|    for prefix in _valid_string_prefixes:
    91|         0|            0|            0|  0.00%|        for t in _itertools.permutations(prefix):
    92|         0|            0|            0|  0.00%|            # create a list with upper and lower versions of each
    93|         0|            0|            0|  0.00%|            #  character
    94|         0|            0|            0|  0.00%|            for u in _itertools.product(*[(c, c.upper()) for c in t]):
    95|         0|            0|            0|  0.00%|                result.add(''.join(u))
    96|         0|            0|            0|  0.00%|    return result
    97|         0|            0|            0|  0.00%|
    98|         0|            0|            0|  0.00%|def _compile(expr):
    99|         0|            0|            0|  0.00%|    return re.compile(expr, re.UNICODE)
   100|         0|            0|            0|  0.00%|
   101|         0|            0|            0|  0.00%|# Note that since _all_string_prefixes includes the empty string,
   102|         0|            0|            0|  0.00%|#  StringPrefix can be the empty string (making it optional).
   103|         0|            0|            0|  0.00%|StringPrefix = group(*_all_string_prefixes())
   104|         0|            0|            0|  0.00%|
   105|         0|            0|            0|  0.00%|# Tail end of ' string.
   106|         0|            0|            0|  0.00%|Single = r"[^'\\]*(?:\\.[^'\\]*)*'"
   107|         0|            0|            0|  0.00%|# Tail end of " string.
   108|         0|            0|            0|  0.00%|Double = r'[^"\\]*(?:\\.[^"\\]*)*"'
   109|         0|            0|            0|  0.00%|# Tail end of ''' string.
   110|         0|            0|            0|  0.00%|Single3 = r"[^'\\]*(?:(?:\\.|'(?!''))[^'\\]*)*'''"
   111|         0|            0|            0|  0.00%|# Tail end of """ string.
   112|         0|            0|            0|  0.00%|Double3 = r'[^"\\]*(?:(?:\\.|"(?!""))[^"\\]*)*"""'
   113|         0|            0|            0|  0.00%|Triple = group(StringPrefix + "'''", StringPrefix + '"""')
   114|         0|            0|            0|  0.00%|# Single-line ' or " string.
   115|         0|            0|            0|  0.00%|String = group(StringPrefix + r"'[^\n'\\]*(?:\\.[^\n'\\]*)*'",
   116|         0|            0|            0|  0.00%|               StringPrefix + r'"[^\n"\\]*(?:\\.[^\n"\\]*)*"')
   117|         0|            0|            0|  0.00%|
   118|         0|            0|            0|  0.00%|# Sorting in reverse order puts the long operators before their prefixes.
   119|         0|            0|            0|  0.00%|# Otherwise if = came before ==, == would get recognized as two instances
   120|         0|            0|            0|  0.00%|# of =.
   121|         0|            0|            0|  0.00%|Special = group(*map(re.escape, sorted(EXACT_TOKEN_TYPES, reverse=True)))
   122|         0|            0|            0|  0.00%|Funny = group(r'\r?\n', Special)
   123|         0|            0|            0|  0.00%|
   124|         0|            0|            0|  0.00%|PlainToken = group(Number, Funny, String, Name)
   125|         0|            0|            0|  0.00%|Token = Ignore + PlainToken
   126|         0|            0|            0|  0.00%|
   127|         0|            0|            0|  0.00%|# First (or only) line of ' or " string.
   128|         0|            0|            0|  0.00%|ContStr = group(StringPrefix + r"'[^\n'\\]*(?:\\.[^\n'\\]*)*" +
   129|         0|            0|            0|  0.00%|                group("'", r'\\\r?\n'),
   130|         0|            0|            0|  0.00%|                StringPrefix + r'"[^\n"\\]*(?:\\.[^\n"\\]*)*' +
   131|         0|            0|            0|  0.00%|                group('"', r'\\\r?\n'))
   132|         0|            0|            0|  0.00%|PseudoExtras = group(r'\\\r?\n|\Z', Comment, Triple)
   133|         0|            0|            0|  0.00%|PseudoToken = Whitespace + group(PseudoExtras, Number, Funny, ContStr, Name)
   134|         0|            0|            0|  0.00%|
   135|         0|            0|            0|  0.00%|# For a given string prefix plus quotes, endpats maps it to a regex
   136|         0|            0|            0|  0.00%|#  to match the remainder of that string. _prefix can be empty, for
   137|         0|            0|            0|  0.00%|#  a normal single or triple quoted string (with no prefix).
   138|         0|            0|            0|  0.00%|endpats = {}
   139|         0|            0|            0|  0.00%|for _prefix in _all_string_prefixes():
   140|         0|            0|            0|  0.00%|    endpats[_prefix + "'"] = Single
   141|         0|            0|            0|  0.00%|    endpats[_prefix + '"'] = Double
   142|         0|            0|            0|  0.00%|    endpats[_prefix + "'''"] = Single3
   143|         0|            0|            0|  0.00%|    endpats[_prefix + '"""'] = Double3
   144|         0|            0|            0|  0.00%|
   145|         0|            0|            0|  0.00%|# A set of all of the single and triple quoted string prefixes,
   146|         0|            0|            0|  0.00%|#  including the opening quotes.
   147|         0|            0|            0|  0.00%|single_quoted = set()
   148|         0|            0|            0|  0.00%|triple_quoted = set()
   149|         0|            0|            0|  0.00%|for t in _all_string_prefixes():
   150|         0|            0|            0|  0.00%|    for u in (t + '"', t + "'"):
   151|         0|            0|            0|  0.00%|        single_quoted.add(u)
   152|         0|            0|            0|  0.00%|    for u in (t + '"""', t + "'''"):
   153|         0|            0|            0|  0.00%|        triple_quoted.add(u)
   154|         0|            0|            0|  0.00%|
   155|         0|            0|            0|  0.00%|tabsize = 8
   156|         0|            0|            0|  0.00%|
   157|         0|            0|            0|  0.00%|class TokenError(Exception): pass
   158|         0|            0|            0|  0.00%|
   159|         0|            0|            0|  0.00%|class StopTokenizing(Exception): pass
   160|         0|            0|            0|  0.00%|
   161|         0|            0|            0|  0.00%|
   162|         0|            0|            0|  0.00%|class Untokenizer:
   163|         0|            0|            0|  0.00%|
   164|         0|            0|            0|  0.00%|    def __init__(self):
   165|         0|            0|            0|  0.00%|        self.tokens = []
   166|         0|            0|            0|  0.00%|        self.prev_row = 1
   167|         0|            0|            0|  0.00%|        self.prev_col = 0
   168|         0|            0|            0|  0.00%|        self.encoding = None
   169|         0|            0|            0|  0.00%|
   170|         0|            0|            0|  0.00%|    def add_whitespace(self, start):
   171|         0|            0|            0|  0.00%|        row, col = start
   172|         0|            0|            0|  0.00%|        if row < self.prev_row or row == self.prev_row and col < self.prev_col:
   173|         0|            0|            0|  0.00%|            raise ValueError("start ({},{}) precedes previous end ({},{})"
   174|         0|            0|            0|  0.00%|                             .format(row, col, self.prev_row, self.prev_col))
   175|         0|            0|            0|  0.00%|        row_offset = row - self.prev_row
   176|         0|            0|            0|  0.00%|        if row_offset:
   177|         0|            0|            0|  0.00%|            self.tokens.append("\\\n" * row_offset)
   178|         0|            0|            0|  0.00%|            self.prev_col = 0
   179|         0|            0|            0|  0.00%|        col_offset = col - self.prev_col
   180|         0|            0|            0|  0.00%|        if col_offset:
   181|         0|            0|            0|  0.00%|            self.tokens.append(" " * col_offset)
   182|         0|            0|            0|  0.00%|
   183|         0|            0|            0|  0.00%|    def untokenize(self, iterable):
   184|         0|            0|            0|  0.00%|        it = iter(iterable)
   185|         0|            0|            0|  0.00%|        indents = []
   186|         0|            0|            0|  0.00%|        startline = False
   187|         0|            0|            0|  0.00%|        for t in it:
   188|         0|            0|            0|  0.00%|            if len(t) == 2:
   189|         0|            0|            0|  0.00%|                self.compat(t, it)
   190|         0|            0|            0|  0.00%|                break
   191|         0|            0|            0|  0.00%|            tok_type, token, start, end, line = t
   192|         0|            0|            0|  0.00%|            if tok_type == ENCODING:
   193|         0|            0|            0|  0.00%|                self.encoding = token
   194|         0|            0|            0|  0.00%|                continue
   195|         0|            0|            0|  0.00%|            if tok_type == ENDMARKER:
   196|         0|            0|            0|  0.00%|                break
   197|         0|            0|            0|  0.00%|            if tok_type == INDENT:
   198|         0|            0|            0|  0.00%|                indents.append(token)
   199|         0|            0|            0|  0.00%|                continue
   200|         0|            0|            0|  0.00%|            elif tok_type == DEDENT:
   201|         0|            0|            0|  0.00%|                indents.pop()
   202|         0|            0|            0|  0.00%|                self.prev_row, self.prev_col = end
   203|         0|            0|            0|  0.00%|                continue
   204|         0|            0|            0|  0.00%|            elif tok_type in (NEWLINE, NL):
   205|         0|            0|            0|  0.00%|                startline = True
   206|         0|            0|            0|  0.00%|            elif startline and indents:
   207|         0|            0|            0|  0.00%|                indent = indents[-1]
   208|         0|            0|            0|  0.00%|                if start[1] >= len(indent):
   209|         0|            0|            0|  0.00%|                    self.tokens.append(indent)
   210|         0|            0|            0|  0.00%|                    self.prev_col = len(indent)
   211|         0|            0|            0|  0.00%|                startline = False
   212|         0|            0|            0|  0.00%|            self.add_whitespace(start)
   213|         0|            0|            0|  0.00%|            self.tokens.append(token)
   214|         0|            0|            0|  0.00%|            self.prev_row, self.prev_col = end
   215|         0|            0|            0|  0.00%|            if tok_type in (NEWLINE, NL):
   216|         0|            0|            0|  0.00%|                self.prev_row += 1
   217|         0|            0|            0|  0.00%|                self.prev_col = 0
   218|         0|            0|            0|  0.00%|        return "".join(self.tokens)
   219|         0|            0|            0|  0.00%|
   220|         0|            0|            0|  0.00%|    def compat(self, token, iterable):
   221|         0|            0|            0|  0.00%|        indents = []
   222|         0|            0|            0|  0.00%|        toks_append = self.tokens.append
   223|         0|            0|            0|  0.00%|        startline = token[0] in (NEWLINE, NL)
   224|         0|            0|            0|  0.00%|        prevstring = False
   225|         0|            0|            0|  0.00%|
   226|         0|            0|            0|  0.00%|        for tok in _itertools.chain([token], iterable):
   227|         0|            0|            0|  0.00%|            toknum, tokval = tok[:2]
   228|         0|            0|            0|  0.00%|            if toknum == ENCODING:
   229|         0|            0|            0|  0.00%|                self.encoding = tokval
   230|         0|            0|            0|  0.00%|                continue
   231|         0|            0|            0|  0.00%|
   232|         0|            0|            0|  0.00%|            if toknum in (NAME, NUMBER):
   233|         0|            0|            0|  0.00%|                tokval += ' '
   234|         0|            0|            0|  0.00%|
   235|         0|            0|            0|  0.00%|            # Insert a space between two consecutive strings
   236|         0|            0|            0|  0.00%|            if toknum == STRING:
   237|         0|            0|            0|  0.00%|                if prevstring:
   238|         0|            0|            0|  0.00%|                    tokval = ' ' + tokval
   239|         0|            0|            0|  0.00%|                prevstring = True
   240|         0|            0|            0|  0.00%|            else:
   241|         0|            0|            0|  0.00%|                prevstring = False
   242|         0|            0|            0|  0.00%|
   243|         0|            0|            0|  0.00%|            if toknum == INDENT:
   244|         0|            0|            0|  0.00%|                indents.append(tokval)
   245|         0|            0|            0|  0.00%|                continue
   246|         0|            0|            0|  0.00%|            elif toknum == DEDENT:
   247|         0|            0|            0|  0.00%|                indents.pop()
   248|         0|            0|            0|  0.00%|                continue
   249|         0|            0|            0|  0.00%|            elif toknum in (NEWLINE, NL):
   250|         0|            0|            0|  0.00%|                startline = True
   251|         0|            0|            0|  0.00%|            elif startline and indents:
   252|         0|            0|            0|  0.00%|                toks_append(indents[-1])
   253|         0|            0|            0|  0.00%|                startline = False
   254|         0|            0|            0|  0.00%|            toks_append(tokval)
   255|         0|            0|            0|  0.00%|
   256|         0|            0|            0|  0.00%|
   257|         0|            0|            0|  0.00%|def untokenize(iterable):
   258|         0|            0|            0|  0.00%|    """Transform tokens back into Python source code.
   259|         0|            0|            0|  0.00%|    It returns a bytes object, encoded using the ENCODING
   260|         0|            0|            0|  0.00%|    token, which is the first token sequence output by tokenize.
   261|         0|            0|            0|  0.00%|
   262|         0|            0|            0|  0.00%|    Each element returned by the iterable must be a token sequence
   263|         0|            0|            0|  0.00%|    with at least two elements, a token number and token value.  If
   264|         0|            0|            0|  0.00%|    only two tokens are passed, the resulting output is poor.
   265|         0|            0|            0|  0.00%|
   266|         0|            0|            0|  0.00%|    Round-trip invariant for full input:
   267|         0|            0|            0|  0.00%|        Untokenized source will match input source exactly
   268|         0|            0|            0|  0.00%|
   269|         0|            0|            0|  0.00%|    Round-trip invariant for limited input:
   270|         0|            0|            0|  0.00%|        # Output bytes will tokenize back to the input
   271|         0|            0|            0|  0.00%|        t1 = [tok[:2] for tok in tokenize(f.readline)]
   272|         0|            0|            0|  0.00%|        newcode = untokenize(t1)
   273|         0|            0|            0|  0.00%|        readline = BytesIO(newcode).readline
   274|         0|            0|            0|  0.00%|        t2 = [tok[:2] for tok in tokenize(readline)]
   275|         0|            0|            0|  0.00%|        assert t1 == t2
   276|         0|            0|            0|  0.00%|    """
   277|         0|            0|            0|  0.00%|    ut = Untokenizer()
   278|         0|            0|            0|  0.00%|    out = ut.untokenize(iterable)
   279|         0|            0|            0|  0.00%|    if ut.encoding is not None:
   280|         0|            0|            0|  0.00%|        out = out.encode(ut.encoding)
   281|         0|            0|            0|  0.00%|    return out
   282|         0|            0|            0|  0.00%|
   283|         0|            0|            0|  0.00%|
   284|         0|            0|            0|  0.00%|def _get_normal_name(orig_enc):
   285|         0|            0|            0|  0.00%|    """Imitates get_normal_name in tokenizer.c."""
   286|         0|            0|            0|  0.00%|    # Only care about the first 12 characters.
   287|         0|            0|            0|  0.00%|    enc = orig_enc[:12].lower().replace("_", "-")
   288|         0|            0|            0|  0.00%|    if enc == "utf-8" or enc.startswith("utf-8-"):
   289|         0|            0|            0|  0.00%|        return "utf-8"
   290|         0|            0|            0|  0.00%|    if enc in ("latin-1", "iso-8859-1", "iso-latin-1") or \
   291|         0|            0|            0|  0.00%|       enc.startswith(("latin-1-", "iso-8859-1-", "iso-latin-1-")):
   292|         0|            0|            0|  0.00%|        return "iso-8859-1"
   293|         0|            0|            0|  0.00%|    return orig_enc
   294|         0|            0|            0|  0.00%|
   295|         1|            0|            0|  0.00%|def detect_encoding(readline):
   296|         0|            0|            0|  0.00%|    """
   297|         0|            0|            0|  0.00%|    The detect_encoding() function is used to detect the encoding that should
   298|         0|            0|            0|  0.00%|    be used to decode a Python source file.  It requires one argument, readline,
   299|         0|            0|            0|  0.00%|    in the same way as the tokenize() generator.
   300|         0|            0|            0|  0.00%|
   301|         0|            0|            0|  0.00%|    It will call readline a maximum of twice, and return the encoding used
   302|         0|            0|            0|  0.00%|    (as a string) and a list of any lines (left as bytes) it has read in.
   303|         0|            0|            0|  0.00%|
   304|         0|            0|            0|  0.00%|    It detects the encoding from the presence of a utf-8 bom or an encoding
   305|         0|            0|            0|  0.00%|    cookie as specified in pep-0263.  If both a bom and a cookie are present,
   306|         0|            0|            0|  0.00%|    but disagree, a SyntaxError will be raised.  If the encoding cookie is an
   307|         0|            0|            0|  0.00%|    invalid charset, raise a SyntaxError.  Note that if a utf-8 bom is found,
   308|         0|            0|            0|  0.00%|    'utf-8-sig' is returned.
   309|         0|            0|            0|  0.00%|
   310|         0|            0|            0|  0.00%|    If no encoding is specified, then the default of 'utf-8' will be returned.
   311|         0|            0|            0|  0.00%|    """
   312|         1|   0.00100112|   0.00100112|  0.01%|    try:
   313|         1|            0|            0|  0.00%|        filename = readline.__self__.name
   314|         0|            0|            0|  0.00%|    except AttributeError:
   315|         0|            0|            0|  0.00%|        filename = None
   316|         1|            0|            0|  0.00%|    bom_found = False
   317|         1|            0|            0|  0.00%|    encoding = None
   318|         1|            0|            0|  0.00%|    default = 'utf-8'
   319|         2|            0|            0|  0.00%|    def read_or_stop():
   320|         1|            0|            0|  0.00%|        try:
   321|         1|            0|            0|  0.00%|            return readline()
   322|         0|            0|            0|  0.00%|        except StopIteration:
   323|         0|            0|            0|  0.00%|            return b''
   324|         0|            0|            0|  0.00%|
   325|         2|            0|            0|  0.00%|    def find_cookie(line):
   326|         1|            0|            0|  0.00%|        try:
   327|         0|            0|            0|  0.00%|            # Decode as UTF-8. Either the line is an encoding declaration,
   328|         0|            0|            0|  0.00%|            # in which case it should be pure ASCII, or it must be UTF-8
   329|         0|            0|            0|  0.00%|            # per default encoding.
   330|         1|            0|            0|  0.00%|            line_string = line.decode('utf-8')
   331|         0|            0|            0|  0.00%|        except UnicodeDecodeError:
   332|         0|            0|            0|  0.00%|            msg = "invalid or missing encoding declaration"
   333|         0|            0|            0|  0.00%|            if filename is not None:
   334|         0|            0|            0|  0.00%|                msg = '{} for {!r}'.format(msg, filename)
   335|         0|            0|            0|  0.00%|            raise SyntaxError(msg)
   336|         0|            0|            0|  0.00%|
   337|         1|            0|            0|  0.00%|        match = cookie_re.match(line_string)
   338|         1|            0|            0|  0.00%|        if not match:
   339|         1|            0|            0|  0.00%|            return None
   340|         0|            0|            0|  0.00%|        encoding = _get_normal_name(match.group(1))
   341|         0|            0|            0|  0.00%|        try:
   342|         0|            0|            0|  0.00%|            codec = lookup(encoding)
   343|         0|            0|            0|  0.00%|        except LookupError:
   344|         0|            0|            0|  0.00%|            # This behaviour mimics the Python interpreter
   345|         0|            0|            0|  0.00%|            if filename is None:
   346|         0|            0|            0|  0.00%|                msg = "unknown encoding: " + encoding
   347|         0|            0|            0|  0.00%|            else:
   348|         0|            0|            0|  0.00%|                msg = "unknown encoding for {!r}: {}".format(filename,
   349|         0|            0|            0|  0.00%|                        encoding)
   350|         0|            0|            0|  0.00%|            raise SyntaxError(msg)
   351|         0|            0|            0|  0.00%|
   352|         0|            0|            0|  0.00%|        if bom_found:
   353|         0|            0|            0|  0.00%|            if encoding != 'utf-8':
   354|         0|            0|            0|  0.00%|                # This behaviour mimics the Python interpreter
   355|         0|            0|            0|  0.00%|                if filename is None:
   356|         0|            0|            0|  0.00%|                    msg = 'encoding problem: utf-8'
   357|         0|            0|            0|  0.00%|                else:
   358|         0|            0|            0|  0.00%|                    msg = 'encoding problem for {!r}: utf-8'.format(filename)
   359|         0|            0|            0|  0.00%|                raise SyntaxError(msg)
   360|         0|            0|            0|  0.00%|            encoding += '-sig'
   361|         0|            0|            0|  0.00%|        return encoding
   362|         0|            0|            0|  0.00%|
   363|         1|            0|            0|  0.00%|    first = read_or_stop()
(call)|         1|            0|            0|  0.00%|# C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.8_3.8.1520.0_x64__qbz5n2kfra8p0\lib\tokenize.py:319 read_or_stop
   364|         1|            0|            0|  0.00%|    if first.startswith(BOM_UTF8):
   365|         0|            0|            0|  0.00%|        bom_found = True
   366|         0|            0|            0|  0.00%|        first = first[3:]
   367|         0|            0|            0|  0.00%|        default = 'utf-8-sig'
   368|         1|            0|            0|  0.00%|    if not first:
   369|         0|            0|            0|  0.00%|        return default, []
   370|         0|            0|            0|  0.00%|
   371|         1|            0|            0|  0.00%|    encoding = find_cookie(first)
(call)|         1|            0|            0|  0.00%|# C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.8_3.8.1520.0_x64__qbz5n2kfra8p0\lib\tokenize.py:325 find_cookie
   372|         1|            0|            0|  0.00%|    if encoding:
   373|         0|            0|            0|  0.00%|        return encoding, [first]
   374|         1|            0|            0|  0.00%|    if not blank_re.match(first):
   375|         1|            0|            0|  0.00%|        return default, [first]
   376|         0|            0|            0|  0.00%|
   377|         0|            0|            0|  0.00%|    second = read_or_stop()
   378|         0|            0|            0|  0.00%|    if not second:
   379|         0|            0|            0|  0.00%|        return default, [first]
   380|         0|            0|            0|  0.00%|
   381|         0|            0|            0|  0.00%|    encoding = find_cookie(second)
   382|         0|            0|            0|  0.00%|    if encoding:
   383|         0|            0|            0|  0.00%|        return encoding, [first, second]
   384|         0|            0|            0|  0.00%|
   385|         0|            0|            0|  0.00%|    return default, [first, second]
   386|         0|            0|            0|  0.00%|
   387|         0|            0|            0|  0.00%|
   388|         1|            0|            0|  0.00%|def open(filename):
   389|         0|            0|            0|  0.00%|    """Open a file in read only mode using the encoding detected by
   390|         0|            0|            0|  0.00%|    detect_encoding().
   391|         0|            0|            0|  0.00%|    """
   392|         1|            0|            0|  0.00%|    buffer = _builtin_open(filename, 'rb')
   393|         1|            0|            0|  0.00%|    try:
   394|         1|            0|            0|  0.00%|        encoding, lines = detect_encoding(buffer.readline)
(call)|         1|   0.00100112|   0.00100112|  0.01%|# C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.8_3.8.1520.0_x64__qbz5n2kfra8p0\lib\tokenize.py:295 detect_encoding
   395|         1|            0|            0|  0.00%|        buffer.seek(0)
   396|         1|            0|            0|  0.00%|        text = TextIOWrapper(buffer, encoding, line_buffering=True)
(call)|         1|            0|            0|  0.00%|# C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.8_3.8.1520.0_x64__qbz5n2kfra8p0\lib\codecs.py:309 __init__
   397|         1|            0|            0|  0.00%|        text.mode = 'r'
   398|         1|            0|            0|  0.00%|        return text
   399|         0|            0|            0|  0.00%|    except:
   400|         0|            0|            0|  0.00%|        buffer.close()
   401|         0|            0|            0|  0.00%|        raise
   402|         0|            0|            0|  0.00%|
   403|         0|            0|            0|  0.00%|
   404|         0|            0|            0|  0.00%|def tokenize(readline):
   405|         0|            0|            0|  0.00%|    """
   406|         0|            0|            0|  0.00%|    The tokenize() generator requires one argument, readline, which
   407|         0|            0|            0|  0.00%|    must be a callable object which provides the same interface as the
   408|         0|            0|            0|  0.00%|    readline() method of built-in file objects.  Each call to the function
   409|         0|            0|            0|  0.00%|    should return one line of input as bytes.  Alternatively, readline
   410|         0|            0|            0|  0.00%|    can be a callable function terminating with StopIteration:
   411|         0|            0|            0|  0.00%|        readline = open(myfile, 'rb').__next__  # Example of alternate readline
   412|         0|            0|            0|  0.00%|
   413|         0|            0|            0|  0.00%|    The generator produces 5-tuples with these members: the token type; the
   414|         0|            0|            0|  0.00%|    token string; a 2-tuple (srow, scol) of ints specifying the row and
   415|         0|            0|            0|  0.00%|    column where the token begins in the source; a 2-tuple (erow, ecol) of
   416|         0|            0|            0|  0.00%|    ints specifying the row and column where the token ends in the source;
   417|         0|            0|            0|  0.00%|    and the line on which the token was found.  The line passed is the
   418|         0|            0|            0|  0.00%|    physical line.
   419|         0|            0|            0|  0.00%|
   420|         0|            0|            0|  0.00%|    The first token sequence will always be an ENCODING token
   421|         0|            0|            0|  0.00%|    which tells you which encoding was used to decode the bytes stream.
   422|         0|            0|            0|  0.00%|    """
   423|         0|            0|            0|  0.00%|    encoding, consumed = detect_encoding(readline)
   424|         0|            0|            0|  0.00%|    empty = _itertools.repeat(b"")
   425|         0|            0|            0|  0.00%|    rl_gen = _itertools.chain(consumed, iter(readline, b""), empty)
   426|         0|            0|            0|  0.00%|    return _tokenize(rl_gen.__next__, encoding)
   427|         0|            0|            0|  0.00%|
   428|         0|            0|            0|  0.00%|
   429|         0|            0|            0|  0.00%|def _tokenize(readline, encoding):
   430|         0|            0|            0|  0.00%|    lnum = parenlev = continued = 0
   431|         0|            0|            0|  0.00%|    numchars = '0123456789'
   432|         0|            0|            0|  0.00%|    contstr, needcont = '', 0
   433|         0|            0|            0|  0.00%|    contline = None
   434|         0|            0|            0|  0.00%|    indents = [0]
   435|         0|            0|            0|  0.00%|
   436|         0|            0|            0|  0.00%|    if encoding is not None:
   437|         0|            0|            0|  0.00%|        if encoding == "utf-8-sig":
   438|         0|            0|            0|  0.00%|            # BOM will already have been stripped.
   439|         0|            0|            0|  0.00%|            encoding = "utf-8"
   440|         0|            0|            0|  0.00%|        yield TokenInfo(ENCODING, encoding, (0, 0), (0, 0), '')
   441|         0|            0|            0|  0.00%|    last_line = b''
   442|         0|            0|            0|  0.00%|    line = b''
   443|         0|            0|            0|  0.00%|    while True:                                # loop over lines in stream
   444|         0|            0|            0|  0.00%|        try:
   445|         0|            0|            0|  0.00%|            # We capture the value of the line variable here because
   446|         0|            0|            0|  0.00%|            # readline uses the empty string '' to signal end of input,
   447|         0|            0|            0|  0.00%|            # hence `line` itself will always be overwritten at the end
   448|         0|            0|            0|  0.00%|            # of this loop.
   449|         0|            0|            0|  0.00%|            last_line = line
   450|         0|            0|            0|  0.00%|            line = readline()
   451|         0|            0|            0|  0.00%|        except StopIteration:
   452|         0|            0|            0|  0.00%|            line = b''
   453|         0|            0|            0|  0.00%|
   454|         0|            0|            0|  0.00%|        if encoding is not None:
   455|         0|            0|            0|  0.00%|            line = line.decode(encoding)
   456|         0|            0|            0|  0.00%|        lnum += 1
   457|         0|            0|            0|  0.00%|        pos, max = 0, len(line)
   458|         0|            0|            0|  0.00%|
   459|         0|            0|            0|  0.00%|        if contstr:                            # continued string
   460|         0|            0|            0|  0.00%|            if not line:
   461|         0|            0|            0|  0.00%|                raise TokenError("EOF in multi-line string", strstart)
   462|         0|            0|            0|  0.00%|            endmatch = endprog.match(line)
   463|         0|            0|            0|  0.00%|            if endmatch:
   464|         0|            0|            0|  0.00%|                pos = end = endmatch.end(0)
   465|         0|            0|            0|  0.00%|                yield TokenInfo(STRING, contstr + line[:end],
   466|         0|            0|            0|  0.00%|                       strstart, (lnum, end), contline + line)
   467|         0|            0|            0|  0.00%|                contstr, needcont = '', 0
   468|         0|            0|            0|  0.00%|                contline = None
   469|         0|            0|            0|  0.00%|            elif needcont and line[-2:] != '\\\n' and line[-3:] != '\\\r\n':
   470|         0|            0|            0|  0.00%|                yield TokenInfo(ERRORTOKEN, contstr + line,
   471|         0|            0|            0|  0.00%|                           strstart, (lnum, len(line)), contline)
   472|         0|            0|            0|  0.00%|                contstr = ''
   473|         0|            0|            0|  0.00%|                contline = None
   474|         0|            0|            0|  0.00%|                continue
   475|         0|            0|            0|  0.00%|            else:
   476|         0|            0|            0|  0.00%|                contstr = contstr + line
   477|         0|            0|            0|  0.00%|                contline = contline + line
   478|         0|            0|            0|  0.00%|                continue
   479|         0|            0|            0|  0.00%|
   480|         0|            0|            0|  0.00%|        elif parenlev == 0 and not continued:  # new statement
   481|         0|            0|            0|  0.00%|            if not line: break
   482|         0|            0|            0|  0.00%|            column = 0
   483|         0|            0|            0|  0.00%|            while pos < max:                   # measure leading whitespace
   484|         0|            0|            0|  0.00%|                if line[pos] == ' ':
   485|         0|            0|            0|  0.00%|                    column += 1
   486|         0|            0|            0|  0.00%|                elif line[pos] == '\t':
   487|         0|            0|            0|  0.00%|                    column = (column//tabsize + 1)*tabsize
   488|         0|            0|            0|  0.00%|                elif line[pos] == '\f':
   489|         0|            0|            0|  0.00%|                    column = 0
   490|         0|            0|            0|  0.00%|                else:
   491|         0|            0|            0|  0.00%|                    break
   492|         0|            0|            0|  0.00%|                pos += 1
   493|         0|            0|            0|  0.00%|            if pos == max:
   494|         0|            0|            0|  0.00%|                break
   495|         0|            0|            0|  0.00%|
   496|         0|            0|            0|  0.00%|            if line[pos] in '#\r\n':           # skip comments or blank lines
   497|         0|            0|            0|  0.00%|                if line[pos] == '#':
   498|         0|            0|            0|  0.00%|                    comment_token = line[pos:].rstrip('\r\n')
   499|         0|            0|            0|  0.00%|                    yield TokenInfo(COMMENT, comment_token,
   500|         0|            0|            0|  0.00%|                           (lnum, pos), (lnum, pos + len(comment_token)), line)
   501|         0|            0|            0|  0.00%|                    pos += len(comment_token)
   502|         0|            0|            0|  0.00%|
   503|         0|            0|            0|  0.00%|                yield TokenInfo(NL, line[pos:],
   504|         0|            0|            0|  0.00%|                           (lnum, pos), (lnum, len(line)), line)
   505|         0|            0|            0|  0.00%|                continue
   506|         0|            0|            0|  0.00%|
   507|         0|            0|            0|  0.00%|            if column > indents[-1]:           # count indents or dedents
   508|         0|            0|            0|  0.00%|                indents.append(column)
   509|         0|            0|            0|  0.00%|                yield TokenInfo(INDENT, line[:pos], (lnum, 0), (lnum, pos), line)
   510|         0|            0|            0|  0.00%|            while column < indents[-1]:
   511|         0|            0|            0|  0.00%|                if column not in indents:
   512|         0|            0|            0|  0.00%|                    raise IndentationError(
   513|         0|            0|            0|  0.00%|                        "unindent does not match any outer indentation level",
   514|         0|            0|            0|  0.00%|                        ("<tokenize>", lnum, pos, line))
   515|         0|            0|            0|  0.00%|                indents = indents[:-1]
   516|         0|            0|            0|  0.00%|
   517|         0|            0|            0|  0.00%|                yield TokenInfo(DEDENT, '', (lnum, pos), (lnum, pos), line)
   518|         0|            0|            0|  0.00%|
   519|         0|            0|            0|  0.00%|        else:                                  # continued statement
   520|         0|            0|            0|  0.00%|            if not line:
   521|         0|            0|            0|  0.00%|                raise TokenError("EOF in multi-line statement", (lnum, 0))
   522|         0|            0|            0|  0.00%|            continued = 0
   523|         0|            0|            0|  0.00%|
   524|         0|            0|            0|  0.00%|        while pos < max:
   525|         0|            0|            0|  0.00%|            pseudomatch = _compile(PseudoToken).match(line, pos)
   526|         0|            0|            0|  0.00%|            if pseudomatch:                                # scan for tokens
   527|         0|            0|            0|  0.00%|                start, end = pseudomatch.span(1)
   528|         0|            0|            0|  0.00%|                spos, epos, pos = (lnum, start), (lnum, end), end
   529|         0|            0|            0|  0.00%|                if start == end:
   530|         0|            0|            0|  0.00%|                    continue
   531|         0|            0|            0|  0.00%|                token, initial = line[start:end], line[start]
   532|         0|            0|            0|  0.00%|
   533|         0|            0|            0|  0.00%|                if (initial in numchars or                 # ordinary number
   534|         0|            0|            0|  0.00%|                    (initial == '.' and token != '.' and token != '...')):
   535|         0|            0|            0|  0.00%|                    yield TokenInfo(NUMBER, token, spos, epos, line)
   536|         0|            0|            0|  0.00%|                elif initial in '\r\n':
   537|         0|            0|            0|  0.00%|                    if parenlev > 0:
   538|         0|            0|            0|  0.00%|                        yield TokenInfo(NL, token, spos, epos, line)
   539|         0|            0|            0|  0.00%|                    else:
   540|         0|            0|            0|  0.00%|                        yield TokenInfo(NEWLINE, token, spos, epos, line)
   541|         0|            0|            0|  0.00%|
   542|         0|            0|            0|  0.00%|                elif initial == '#':
   543|         0|            0|            0|  0.00%|                    assert not token.endswith("\n")
   544|         0|            0|            0|  0.00%|                    yield TokenInfo(COMMENT, token, spos, epos, line)
   545|         0|            0|            0|  0.00%|
   546|         0|            0|            0|  0.00%|                elif token in triple_quoted:
   547|         0|            0|            0|  0.00%|                    endprog = _compile(endpats[token])
   548|         0|            0|            0|  0.00%|                    endmatch = endprog.match(line, pos)
   549|         0|            0|            0|  0.00%|                    if endmatch:                           # all on one line
   550|         0|            0|            0|  0.00%|                        pos = endmatch.end(0)
   551|         0|            0|            0|  0.00%|                        token = line[start:pos]
   552|         0|            0|            0|  0.00%|                        yield TokenInfo(STRING, token, spos, (lnum, pos), line)
   553|         0|            0|            0|  0.00%|                    else:
   554|         0|            0|            0|  0.00%|                        strstart = (lnum, start)           # multiple lines
   555|         0|            0|            0|  0.00%|                        contstr = line[start:]
   556|         0|            0|            0|  0.00%|                        contline = line
   557|         0|            0|            0|  0.00%|                        break
   558|         0|            0|            0|  0.00%|
   559|         0|            0|            0|  0.00%|                # Check up to the first 3 chars of the token to see if
   560|         0|            0|            0|  0.00%|                #  they're in the single_quoted set. If so, they start
   561|         0|            0|            0|  0.00%|                #  a string.
   562|         0|            0|            0|  0.00%|                # We're using the first 3, because we're looking for
   563|         0|            0|            0|  0.00%|                #  "rb'" (for example) at the start of the token. If
   564|         0|            0|            0|  0.00%|                #  we switch to longer prefixes, this needs to be
   565|         0|            0|            0|  0.00%|                #  adjusted.
   566|         0|            0|            0|  0.00%|                # Note that initial == token[:1].
   567|         0|            0|            0|  0.00%|                # Also note that single quote checking must come after
   568|         0|            0|            0|  0.00%|                #  triple quote checking (above).
   569|         0|            0|            0|  0.00%|                elif (initial in single_quoted or
   570|         0|            0|            0|  0.00%|                      token[:2] in single_quoted or
   571|         0|            0|            0|  0.00%|                      token[:3] in single_quoted):
   572|         0|            0|            0|  0.00%|                    if token[-1] == '\n':                  # continued string
   573|         0|            0|            0|  0.00%|                        strstart = (lnum, start)
   574|         0|            0|            0|  0.00%|                        # Again, using the first 3 chars of the
   575|         0|            0|            0|  0.00%|                        #  token. This is looking for the matching end
   576|         0|            0|            0|  0.00%|                        #  regex for the correct type of quote
   577|         0|            0|            0|  0.00%|                        #  character. So it's really looking for
   578|         0|            0|            0|  0.00%|                        #  endpats["'"] or endpats['"'], by trying to
   579|         0|            0|            0|  0.00%|                        #  skip string prefix characters, if any.
   580|         0|            0|            0|  0.00%|                        endprog = _compile(endpats.get(initial) or
   581|         0|            0|            0|  0.00%|                                           endpats.get(token[1]) or
   582|         0|            0|            0|  0.00%|                                           endpats.get(token[2]))
   583|         0|            0|            0|  0.00%|                        contstr, needcont = line[start:], 1
   584|         0|            0|            0|  0.00%|                        contline = line
   585|         0|            0|            0|  0.00%|                        break
   586|         0|            0|            0|  0.00%|                    else:                                  # ordinary string
   587|         0|            0|            0|  0.00%|                        yield TokenInfo(STRING, token, spos, epos, line)
   588|         0|            0|            0|  0.00%|
   589|         0|            0|            0|  0.00%|                elif initial.isidentifier():               # ordinary name
   590|         0|            0|            0|  0.00%|                    yield TokenInfo(NAME, token, spos, epos, line)
   591|         0|            0|            0|  0.00%|                elif initial == '\\':                      # continued stmt
   592|         0|            0|            0|  0.00%|                    continued = 1
   593|         0|            0|            0|  0.00%|                else:
   594|         0|            0|            0|  0.00%|                    if initial in '([{':
   595|         0|            0|            0|  0.00%|                        parenlev += 1
   596|         0|            0|            0|  0.00%|                    elif initial in ')]}':
   597|         0|            0|            0|  0.00%|                        parenlev -= 1
   598|         0|            0|            0|  0.00%|                    yield TokenInfo(OP, token, spos, epos, line)
   599|         0|            0|            0|  0.00%|            else:
   600|         0|            0|            0|  0.00%|                yield TokenInfo(ERRORTOKEN, line[pos],
   601|         0|            0|            0|  0.00%|                           (lnum, pos), (lnum, pos+1), line)
   602|         0|            0|            0|  0.00%|                pos += 1
   603|         0|            0|            0|  0.00%|
   604|         0|            0|            0|  0.00%|    # Add an implicit NEWLINE if the input doesn't end in one
   605|         0|            0|            0|  0.00%|    if last_line and last_line[-1] not in '\r\n':
   606|         0|            0|            0|  0.00%|        yield TokenInfo(NEWLINE, '', (lnum - 1, len(last_line)), (lnum - 1, len(last_line) + 1), '')
   607|         0|            0|            0|  0.00%|    for indent in indents[1:]:                 # pop remaining indent levels
   608|         0|            0|            0|  0.00%|        yield TokenInfo(DEDENT, '', (lnum, 0), (lnum, 0), '')
   609|         0|            0|            0|  0.00%|    yield TokenInfo(ENDMARKER, '', (lnum, 0), (lnum, 0), '')
   610|         0|            0|            0|  0.00%|
   611|         0|            0|            0|  0.00%|
   612|         0|            0|            0|  0.00%|def generate_tokens(readline):
   613|         0|            0|            0|  0.00%|    """Tokenize a source reading Python code as unicode strings.
   614|         0|            0|            0|  0.00%|
   615|         0|            0|            0|  0.00%|    This has the same API as tokenize(), except that it expects the *readline*
   616|         0|            0|            0|  0.00%|    callable to return str objects instead of bytes.
   617|         0|            0|            0|  0.00%|    """
   618|         0|            0|            0|  0.00%|    return _tokenize(readline, None)
   619|         0|            0|            0|  0.00%|
   620|         0|            0|            0|  0.00%|def main():
   621|         0|            0|            0|  0.00%|    import argparse
   622|         0|            0|            0|  0.00%|
   623|         0|            0|            0|  0.00%|    # Helper error handling routines
   624|         0|            0|            0|  0.00%|    def perror(message):
   625|         0|            0|            0|  0.00%|        sys.stderr.write(message)
   626|         0|            0|            0|  0.00%|        sys.stderr.write('\n')
   627|         0|            0|            0|  0.00%|
   628|         0|            0|            0|  0.00%|    def error(message, filename=None, location=None):
   629|         0|            0|            0|  0.00%|        if location:
   630|         0|            0|            0|  0.00%|            args = (filename,) + location + (message,)
   631|         0|            0|            0|  0.00%|            perror("%s:%d:%d: error: %s" % args)
   632|         0|            0|            0|  0.00%|        elif filename:
   633|         0|            0|            0|  0.00%|            perror("%s: error: %s" % (filename, message))
   634|         0|            0|            0|  0.00%|        else:
   635|         0|            0|            0|  0.00%|            perror("error: %s" % message)
   636|         0|            0|            0|  0.00%|        sys.exit(1)
   637|         0|            0|            0|  0.00%|
   638|         0|            0|            0|  0.00%|    # Parse the arguments and options
   639|         0|            0|            0|  0.00%|    parser = argparse.ArgumentParser(prog='python -m tokenize')
   640|         0|            0|            0|  0.00%|    parser.add_argument(dest='filename', nargs='?',
   641|         0|            0|            0|  0.00%|                        metavar='filename.py',
   642|         0|            0|            0|  0.00%|                        help='the file to tokenize; defaults to stdin')
   643|         0|            0|            0|  0.00%|    parser.add_argument('-e', '--exact', dest='exact', action='store_true',
   644|         0|            0|            0|  0.00%|                        help='display token names using the exact type')
   645|         0|            0|            0|  0.00%|    args = parser.parse_args()
   646|         0|            0|            0|  0.00%|
   647|         0|            0|            0|  0.00%|    try:
   648|         0|            0|            0|  0.00%|        # Tokenize the input
   649|         0|            0|            0|  0.00%|        if args.filename:
   650|         0|            0|            0|  0.00%|            filename = args.filename
   651|         0|            0|            0|  0.00%|            with _builtin_open(filename, 'rb') as f:
   652|         0|            0|            0|  0.00%|                tokens = list(tokenize(f.readline))
   653|         0|            0|            0|  0.00%|        else:
   654|         0|            0|            0|  0.00%|            filename = "<stdin>"
   655|         0|            0|            0|  0.00%|            tokens = _tokenize(sys.stdin.readline, None)
   656|         0|            0|            0|  0.00%|
   657|         0|            0|            0|  0.00%|        # Output the tokenization
   658|         0|            0|            0|  0.00%|        for token in tokens:
   659|         0|            0|            0|  0.00%|            token_type = token.type
   660|         0|            0|            0|  0.00%|            if args.exact:
   661|         0|            0|            0|  0.00%|                token_type = token.exact_type
   662|         0|            0|            0|  0.00%|            token_range = "%d,%d-%d,%d:" % (token.start + token.end)
   663|         0|            0|            0|  0.00%|            print("%-20s%-15s%-15r" %
   664|         0|            0|            0|  0.00%|                  (token_range, tok_name[token_type], token.string))
   665|         0|            0|            0|  0.00%|    except IndentationError as err:
   666|         0|            0|            0|  0.00%|        line, column = err.args[1][1:3]
   667|         0|            0|            0|  0.00%|        error(err.args[0], filename, (line, column))
   668|         0|            0|            0|  0.00%|    except TokenError as err:
   669|         0|            0|            0|  0.00%|        line, column = err.args[1]
   670|         0|            0|            0|  0.00%|        error(err.args[0], filename, (line, column))
   671|         0|            0|            0|  0.00%|    except SyntaxError as err:
   672|         0|            0|            0|  0.00%|        error(err, filename)
   673|         0|            0|            0|  0.00%|    except OSError as err:
   674|         0|            0|            0|  0.00%|        error(err)
   675|         0|            0|            0|  0.00%|    except KeyboardInterrupt:
   676|         0|            0|            0|  0.00%|        print("interrupted\n")
   677|         0|            0|            0|  0.00%|    except Exception as err:
   678|         0|            0|            0|  0.00%|        perror("unexpected error: %s" % err)
   679|         0|            0|            0|  0.00%|        raise
   680|         0|            0|            0|  0.00%|
   681|         0|            0|            0|  0.00%|if __name__ == "__main__":
   682|         0|            0|            0|  0.00%|    main()
File: C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.8_3.8.1520.0_x64__qbz5n2kfra8p0\lib\_bootlocale.py
File duration: 0.00100088s (0.01%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""A minimal subset of the locale module used at interpreter startup
     2|         0|            0|            0|  0.00%|(imported by the _io module), in order to reduce startup time.
     3|         0|            0|            0|  0.00%|
     4|         0|            0|            0|  0.00%|Don't import directly from third-party code; use the `locale` module instead!
     5|         0|            0|            0|  0.00%|"""
     6|         0|            0|            0|  0.00%|
     7|         0|            0|            0|  0.00%|import sys
     8|         0|            0|            0|  0.00%|import _locale
     9|         0|            0|            0|  0.00%|
    10|         0|            0|            0|  0.00%|if sys.platform.startswith("win"):
    11|         2|            0|            0|  0.00%|    def getpreferredencoding(do_setlocale=True):
    12|         2|   0.00100088|  0.000500441|  0.01%|        if sys.flags.utf8_mode:
    13|         0|            0|            0|  0.00%|            return 'UTF-8'
    14|         2|            0|            0|  0.00%|        return _locale._getdefaultlocale()[1]
    15|         0|            0|            0|  0.00%|else:
    16|         0|            0|            0|  0.00%|    try:
    17|         0|            0|            0|  0.00%|        _locale.CODESET
    18|         0|            0|            0|  0.00%|    except AttributeError:
    19|         0|            0|            0|  0.00%|        if hasattr(sys, 'getandroidapilevel'):
    20|         0|            0|            0|  0.00%|            # On Android langinfo.h and CODESET are missing, and UTF-8 is
    21|         0|            0|            0|  0.00%|            # always used in mbstowcs() and wcstombs().
    22|         0|            0|            0|  0.00%|            def getpreferredencoding(do_setlocale=True):
    23|         0|            0|            0|  0.00%|                return 'UTF-8'
    24|         0|            0|            0|  0.00%|        else:
    25|         0|            0|            0|  0.00%|            def getpreferredencoding(do_setlocale=True):
    26|         0|            0|            0|  0.00%|                if sys.flags.utf8_mode:
    27|         0|            0|            0|  0.00%|                    return 'UTF-8'
    28|         0|            0|            0|  0.00%|                # This path for legacy systems needs the more complex
    29|         0|            0|            0|  0.00%|                # getdefaultlocale() function, import the full locale module.
    30|         0|            0|            0|  0.00%|                import locale
    31|         0|            0|            0|  0.00%|                return locale.getpreferredencoding(do_setlocale)
    32|         0|            0|            0|  0.00%|    else:
    33|         0|            0|            0|  0.00%|        def getpreferredencoding(do_setlocale=True):
    34|         0|            0|            0|  0.00%|            assert not do_setlocale
    35|         0|            0|            0|  0.00%|            if sys.flags.utf8_mode:
    36|         0|            0|            0|  0.00%|                return 'UTF-8'
    37|         0|            0|            0|  0.00%|            result = _locale.nl_langinfo(_locale.CODESET)
    38|         0|            0|            0|  0.00%|            if not result and sys.platform == 'darwin':
    39|         0|            0|            0|  0.00%|                # nl_langinfo can return an empty string
    40|         0|            0|            0|  0.00%|                # when the setting has an invalid value.
    41|         0|            0|            0|  0.00%|                # Default to UTF-8 in that case because
    42|         0|            0|            0|  0.00%|                # UTF-8 is the default charset on OSX and
    43|         0|            0|            0|  0.00%|                # returning nothing will crash the
    44|         0|            0|            0|  0.00%|                # interpreter.
    45|         0|            0|            0|  0.00%|                result = 'UTF-8'
    46|         0|            0|            0|  0.00%|            return result
File: C:\Users\bdode\Documents\Website_projects\SAT\working_learning\SAT-44\code\classes\DPLL.py
File duration: 0.0010004s (0.01%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|import copy
     2|         0|            0|            0|  0.00%|from CNF import CNF_Formula
     3|         0|            0|            0|  0.00%|
     4|         0|            0|            0|  0.00%|# Pseudocode for DPLL recursive
     5|         8|            0|            0|  0.00%|def DPLL(sat_solver):
     6|         0|            0|            0|  0.00%|
     7|         0|            0|            0|  0.00%|    # No clauses left
     8|         8|            0|            0|  0.00%|    if not sat_solver.CNF.active_clauses:
     9|         0|            0|            0|  0.00%|        return "SAT"
    10|         0|            0|            0|  0.00%|
    11|         0|            0|            0|  0.00%|    # The loop is so we can restart here after backtracking
    12|         8|            0|            0|  0.00%|    restart = True
    13|        13|            0|            0|  0.00%|    while restart == True:
    14|        13|            0|            0|  0.00%|        restart = False
    15|         0|            0|            0|  0.00%|
    16|         0|            0|            0|  0.00%|         # No clauses left
    17|        13|            0|            0|  0.00%|        if not sat_solver.CNF.active_clauses:
    18|         0|            0|            0|  0.00%|            return "SAT"
    19|         0|            0|            0|  0.00%|
    20|         0|            0|            0|  0.00%|        """
    21|         0|            0|            0|  0.00%|        if sat_solver.CNF.current_depth == 4:
    22|         0|            0|            0|  0.00%|            sat_solver.backtracking = True
    23|         0|            0|            0|  0.00%|            sat_solver.backtrack_depth = 0
    24|         0|            0|            0|  0.00%|            sat_solver.CNF.print_total_status()
    25|         0|            0|            0|  0.00%|            return
    26|         0|            0|            0|  0.00%|        """
    27|         0|            0|            0|  0.00%|
    28|         0|            0|            0|  0.00%|        # Pick variable
    29|         0|            0|            0|  0.00%|        # sat_solver.CNF.print_total_status()
    30|        13|            0|            0|  0.00%|        variable = sat_solver.CNF.pick_active_variable("lowest")
(call)|        13|     0.146135|    0.0112411|  0.86%|# C:\Users\bdode\Documents\Website_projects\SAT\working_learning\SAT-44\code\classes\CNF.py:165 pick_active_variable
    31|         0|            0|            0|  0.00%|        # print(variable)
    32|         0|            0|            0|  0.00%|        # Try both True and False
    33|        13|            0|            0|  0.00%|        for boolean in (True, False):
    34|         0|            0|            0|  0.00%|
    35|         0|            0|            0|  0.00%|            # Branch
    36|        13|            0|            0|  0.00%|            sat_solver.CNF.branch(variable, boolean)
(call)|        13|   0.00200272|  0.000154055|  0.01%|# C:\Users\bdode\Documents\Website_projects\SAT\working_learning\SAT-44\code\classes\CNF.py:132 branch
    37|        13|            0|            0|  0.00%|            sat_solver.CNF.remove_unit_clauses()
(call)|        13|       1.1999|    0.0922997|  7.05%|# C:\Users\bdode\Documents\Website_projects\SAT\working_learning\SAT-44\code\classes\CNF.py:185 remove_unit_clauses
    38|         0|            0|            0|  0.00%|
    39|         0|            0|            0|  0.00%|            # sat_solver.CNF.print_total_status()
    40|         0|            0|            0|  0.00%|
    41|         0|            0|            0|  0.00%|            # No clauses left
    42|        13|            0|            0|  0.00%|            if not sat_solver.CNF.active_clauses:
    43|         1|            0|            0|  0.00%|                return "SAT"
    44|         0|            0|            0|  0.00%|
    45|         0|            0|            0|  0.00%|            # check_if_empty_clause
    46|        12|            0|            0|  0.00%|            empty_clause = sat_solver.CNF.contains_empty_clause()
(call)|        12|     0.019017|   0.00158475|  0.11%|# C:\Users\bdode\Documents\Website_projects\SAT\working_learning\SAT-44\code\classes\CNF.py:348 contains_empty_clause
    47|        12|            0|            0|  0.00%|            if empty_clause:
    48|         0|            0|            0|  0.00%|                # print(sat_solver.CNF.clauses_removed_part[str(empty_clause)])
    49|         5|            0|            0|  0.00%|                conflict_id = empty_clause
    50|         0|            0|            0|  0.00%|
    51|         0|            0|            0|  0.00%|                # Learn clause and start backtracking
    52|         5|            0|            0|  0.00%|                backtrack_depth = sat_solver.CNF.learn_clause(conflict_id)
(call)|         5|        0.539|       0.1078|  3.16%|# C:\Users\bdode\Documents\Website_projects\SAT\working_learning\SAT-44\code\classes\CNF.py:249 learn_clause
    53|         0|            0|            0|  0.00%|
    54|         5|            0|            0|  0.00%|                sat_solver.backtracking = True
    55|         5|            0|            0|  0.00%|                sat_solver.backtracking_depth = backtrack_depth
    56|         0|            0|            0|  0.00%|
    57|         5|            0|            0|  0.00%|                sat_solver.CNF.undo_unit_clauses()
(call)|         5|    0.0980897|    0.0196179|  0.58%|# C:\Users\bdode\Documents\Website_projects\SAT\working_learning\SAT-44\code\classes\CNF.py:210 undo_unit_clauses
    58|         5|            0|            0|  0.00%|                sat_solver.CNF.undo_branch(sat_solver.CNF.current_depth)
(call)|         5|   0.00200224|  0.000400448|  0.01%|# C:\Users\bdode\Documents\Website_projects\SAT\working_learning\SAT-44\code\classes\CNF.py:98 undo_branch
    59|         0|            0|            0|  0.00%|
    60|         5|            0|            0|  0.00%|                if sat_solver.CNF.current_depth == 0:
    61|         0|            0|            0|  0.00%|                    sat_solver.CNF.undo_branch(sat_solver.CNF.current_depth)
    62|         0|            0|            0|  0.00%|                    sat_solver.CNF.undo_unit_clauses()
    63|         0|            0|            0|  0.00%|
    64|         0|            0|            0|  0.00%|                    sat_solver.backtracking = False
    65|         0|            0|            0|  0.00%|                    sat_solver.backtrack_depth = None
    66|         0|            0|            0|  0.00%|                    restart = True
    67|         0|            0|            0|  0.00%|                    break
    68|         0|            0|            0|  0.00%|
    69|         5|            0|            0|  0.00%|                return "UNSAT 1"
    70|         0|            0|            0|  0.00%|
    71|         0|            0|            0|  0.00%|            # Recursive call
    72|         7|            0|            0|  0.00%|            sat_solver.CNF.current_depth += 1
    73|         7|            0|            0|  0.00%|            result = DPLL(sat_solver)
(call)|         7|      2.06119|     0.294456| 12.10%|# C:\Users\bdode\Documents\Website_projects\SAT\working_learning\SAT-44\code\classes\DPLL.py:5 DPLL
    74|         7|            0|            0|  0.00%|            sat_solver.CNF.current_depth -= 1
    75|         0|            0|            0|  0.00%|
    76|         7|            0|            0|  0.00%|            if sat_solver.backtracking:
    77|         5|    0.0010004|  0.000200081|  0.01%|                print("backtracking: ", sat_solver.CNF.current_depth)
(call)|        20|            0|            0|  0.00%|# C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.8_3.8.1520.0_x64__qbz5n2kfra8p0\lib\encodings\cp1252.py:18 encode
    78|         5|            0|            0|  0.00%|                sat_solver.CNF.undo_branch(sat_solver.CNF.current_depth)
(call)|         5|            0|            0|  0.00%|# C:\Users\bdode\Documents\Website_projects\SAT\working_learning\SAT-44\code\classes\CNF.py:98 undo_branch
    79|         5|            0|            0|  0.00%|                sat_solver.CNF.undo_unit_clauses()
(call)|         5|    0.0550513|    0.0110103|  0.32%|# C:\Users\bdode\Documents\Website_projects\SAT\working_learning\SAT-44\code\classes\CNF.py:210 undo_unit_clauses
    80|         0|            0|            0|  0.00%|
    81|         0|            0|            0|  0.00%|                # Stop backtracking if depth reached
    82|         5|            0|            0|  0.00%|                if sat_solver.backtracking_depth == sat_solver.CNF.current_depth:
    83|         5|            0|            0|  0.00%|                    print("done")
(call)|        10|            0|            0|  0.00%|# C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.8_3.8.1520.0_x64__qbz5n2kfra8p0\lib\encodings\cp1252.py:18 encode
    84|         5|            0|            0|  0.00%|                    sat_solver.backtracking = False
    85|         5|            0|            0|  0.00%|                    sat_solver.backtrack_depth = None
    86|         0|            0|            0|  0.00%|
    87|         0|            0|            0|  0.00%|
    88|         0|            0|            0|  0.00%|                    # Go to the top of the function
    89|         5|            0|            0|  0.00%|                    restart = True
    90|         5|            0|            0|  0.00%|                    break
    91|         0|            0|            0|  0.00%|
    92|         0|            0|            0|  0.00%|                # Go one level up
    93|         0|            0|            0|  0.00%|                return
    94|         0|            0|            0|  0.00%|
    95|         2|            0|            0|  0.00%|            if result == "SAT":
    96|         2|            0|            0|  0.00%|                return "SAT"
    97|         0|            0|            0|  0.00%|
    98|         0|            0|            0|  0.00%|            # Undo branching
    99|         0|            0|            0|  0.00%|            sat_solver.CNF.undo_branch(sat_solver.CNF.current_depth)
   100|         0|            0|            0|  0.00%|            sat_solver.CNF.undo_unit_clauses()
   101|         0|            0|            0|  0.00%|
   102|         0|            0|            0|  0.00%|        # If last step of backtracking, go back to top of function
   103|         5|            0|            0|  0.00%|        if restart == True:
   104|         5|            0|            0|  0.00%|            sat_solver.CNF.remove_unit_clauses()
(call)|         5|    0.0220194|   0.00440388|  0.13%|# C:\Users\bdode\Documents\Website_projects\SAT\working_learning\SAT-44\code\classes\CNF.py:185 remove_unit_clauses
   105|         5|            0|            0|  0.00%|            if sat_solver.CNF.contains_empty_clause():
(call)|         5|    0.0200179|   0.00400357|  0.12%|# C:\Users\bdode\Documents\Website_projects\SAT\working_learning\SAT-44\code\classes\CNF.py:348 contains_empty_clause
   106|         0|            0|            0|  0.00%|                return "UNSAT 2"
   107|         0|            0|            0|  0.00%|            continue
   108|         0|            0|            0|  0.00%|
   109|         0|            0|            0|  0.00%|        # If both True and False failed, branch is not possible
   110|         0|            0|            0|  0.00%|        sat_solver.CNF.undo_unit_clauses()
   111|         0|            0|            0|  0.00%|        print("wtf")
   112|         0|            0|            0|  0.00%|        return "UNSAT 2"
File: C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.8_3.8.1520.0_x64__qbz5n2kfra8p0\lib\codecs.py
File duration: 0s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|""" codecs -- Python Codec Registry, API and helpers.
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|
     4|         0|            0|            0|  0.00%|Written by Marc-Andre Lemburg (mal@lemburg.com).
     5|         0|            0|            0|  0.00%|
     6|         0|            0|            0|  0.00%|(c) Copyright CNRI, All Rights Reserved. NO WARRANTY.
     7|         0|            0|            0|  0.00%|
     8|         0|            0|            0|  0.00%|"""
     9|         0|            0|            0|  0.00%|
    10|         0|            0|            0|  0.00%|import builtins
    11|         0|            0|            0|  0.00%|import sys
    12|         0|            0|            0|  0.00%|
    13|         0|            0|            0|  0.00%|### Registry and builtin stateless codec functions
    14|         0|            0|            0|  0.00%|
    15|         0|            0|            0|  0.00%|try:
    16|         0|            0|            0|  0.00%|    from _codecs import *
    17|         0|            0|            0|  0.00%|except ImportError as why:
    18|         0|            0|            0|  0.00%|    raise SystemError('Failed to load the builtin codecs: %s' % why)
    19|         0|            0|            0|  0.00%|
    20|         0|            0|            0|  0.00%|__all__ = ["register", "lookup", "open", "EncodedFile", "BOM", "BOM_BE",
    21|         0|            0|            0|  0.00%|           "BOM_LE", "BOM32_BE", "BOM32_LE", "BOM64_BE", "BOM64_LE",
    22|         0|            0|            0|  0.00%|           "BOM_UTF8", "BOM_UTF16", "BOM_UTF16_LE", "BOM_UTF16_BE",
    23|         0|            0|            0|  0.00%|           "BOM_UTF32", "BOM_UTF32_LE", "BOM_UTF32_BE",
    24|         0|            0|            0|  0.00%|           "CodecInfo", "Codec", "IncrementalEncoder", "IncrementalDecoder",
    25|         0|            0|            0|  0.00%|           "StreamReader", "StreamWriter",
    26|         0|            0|            0|  0.00%|           "StreamReaderWriter", "StreamRecoder",
    27|         0|            0|            0|  0.00%|           "getencoder", "getdecoder", "getincrementalencoder",
    28|         0|            0|            0|  0.00%|           "getincrementaldecoder", "getreader", "getwriter",
    29|         0|            0|            0|  0.00%|           "encode", "decode", "iterencode", "iterdecode",
    30|         0|            0|            0|  0.00%|           "strict_errors", "ignore_errors", "replace_errors",
    31|         0|            0|            0|  0.00%|           "xmlcharrefreplace_errors",
    32|         0|            0|            0|  0.00%|           "backslashreplace_errors", "namereplace_errors",
    33|         0|            0|            0|  0.00%|           "register_error", "lookup_error"]
    34|         0|            0|            0|  0.00%|
    35|         0|            0|            0|  0.00%|### Constants
    36|         0|            0|            0|  0.00%|
    37|         0|            0|            0|  0.00%|#
    38|         0|            0|            0|  0.00%|# Byte Order Mark (BOM = ZERO WIDTH NO-BREAK SPACE = U+FEFF)
    39|         0|            0|            0|  0.00%|# and its possible byte string values
    40|         0|            0|            0|  0.00%|# for UTF8/UTF16/UTF32 output and little/big endian machines
    41|         0|            0|            0|  0.00%|#
    42|         0|            0|            0|  0.00%|
    43|         0|            0|            0|  0.00%|# UTF-8
    44|         0|            0|            0|  0.00%|BOM_UTF8 = b'\xef\xbb\xbf'
    45|         0|            0|            0|  0.00%|
    46|         0|            0|            0|  0.00%|# UTF-16, little endian
    47|         0|            0|            0|  0.00%|BOM_LE = BOM_UTF16_LE = b'\xff\xfe'
    48|         0|            0|            0|  0.00%|
    49|         0|            0|            0|  0.00%|# UTF-16, big endian
    50|         0|            0|            0|  0.00%|BOM_BE = BOM_UTF16_BE = b'\xfe\xff'
    51|         0|            0|            0|  0.00%|
    52|         0|            0|            0|  0.00%|# UTF-32, little endian
    53|         0|            0|            0|  0.00%|BOM_UTF32_LE = b'\xff\xfe\x00\x00'
    54|         0|            0|            0|  0.00%|
    55|         0|            0|            0|  0.00%|# UTF-32, big endian
    56|         0|            0|            0|  0.00%|BOM_UTF32_BE = b'\x00\x00\xfe\xff'
    57|         0|            0|            0|  0.00%|
    58|         0|            0|            0|  0.00%|if sys.byteorder == 'little':
    59|         0|            0|            0|  0.00%|
    60|         0|            0|            0|  0.00%|    # UTF-16, native endianness
    61|         0|            0|            0|  0.00%|    BOM = BOM_UTF16 = BOM_UTF16_LE
    62|         0|            0|            0|  0.00%|
    63|         0|            0|            0|  0.00%|    # UTF-32, native endianness
    64|         0|            0|            0|  0.00%|    BOM_UTF32 = BOM_UTF32_LE
    65|         0|            0|            0|  0.00%|
    66|         0|            0|            0|  0.00%|else:
    67|         0|            0|            0|  0.00%|
    68|         0|            0|            0|  0.00%|    # UTF-16, native endianness
    69|         0|            0|            0|  0.00%|    BOM = BOM_UTF16 = BOM_UTF16_BE
    70|         0|            0|            0|  0.00%|
    71|         0|            0|            0|  0.00%|    # UTF-32, native endianness
    72|         0|            0|            0|  0.00%|    BOM_UTF32 = BOM_UTF32_BE
    73|         0|            0|            0|  0.00%|
    74|         0|            0|            0|  0.00%|# Old broken names (don't use in new code)
    75|         0|            0|            0|  0.00%|BOM32_LE = BOM_UTF16_LE
    76|         0|            0|            0|  0.00%|BOM32_BE = BOM_UTF16_BE
    77|         0|            0|            0|  0.00%|BOM64_LE = BOM_UTF32_LE
    78|         0|            0|            0|  0.00%|BOM64_BE = BOM_UTF32_BE
    79|         0|            0|            0|  0.00%|
    80|         0|            0|            0|  0.00%|
    81|         0|            0|            0|  0.00%|### Codec base classes (defining the API)
    82|         0|            0|            0|  0.00%|
    83|         0|            0|            0|  0.00%|class CodecInfo(tuple):
    84|         0|            0|            0|  0.00%|    """Codec details when looking up the codec registry"""
    85|         0|            0|            0|  0.00%|
    86|         0|            0|            0|  0.00%|    # Private API to allow Python 3.4 to blacklist the known non-Unicode
    87|         0|            0|            0|  0.00%|    # codecs in the standard library. A more general mechanism to
    88|         0|            0|            0|  0.00%|    # reliably distinguish test encodings from other codecs will hopefully
    89|         0|            0|            0|  0.00%|    # be defined for Python 3.5
    90|         0|            0|            0|  0.00%|    #
    91|         0|            0|            0|  0.00%|    # See http://bugs.python.org/issue19619
    92|         0|            0|            0|  0.00%|    _is_text_encoding = True # Assume codecs are text encodings by default
    93|         0|            0|            0|  0.00%|
    94|         0|            0|            0|  0.00%|    def __new__(cls, encode, decode, streamreader=None, streamwriter=None,
    95|         0|            0|            0|  0.00%|        incrementalencoder=None, incrementaldecoder=None, name=None,
    96|         0|            0|            0|  0.00%|        *, _is_text_encoding=None):
    97|         0|            0|            0|  0.00%|        self = tuple.__new__(cls, (encode, decode, streamreader, streamwriter))
    98|         0|            0|            0|  0.00%|        self.name = name
    99|         0|            0|            0|  0.00%|        self.encode = encode
   100|         0|            0|            0|  0.00%|        self.decode = decode
   101|         0|            0|            0|  0.00%|        self.incrementalencoder = incrementalencoder
   102|         0|            0|            0|  0.00%|        self.incrementaldecoder = incrementaldecoder
   103|         0|            0|            0|  0.00%|        self.streamwriter = streamwriter
   104|         0|            0|            0|  0.00%|        self.streamreader = streamreader
   105|         0|            0|            0|  0.00%|        if _is_text_encoding is not None:
   106|         0|            0|            0|  0.00%|            self._is_text_encoding = _is_text_encoding
   107|         0|            0|            0|  0.00%|        return self
   108|         0|            0|            0|  0.00%|
   109|         0|            0|            0|  0.00%|    def __repr__(self):
   110|         0|            0|            0|  0.00%|        return "<%s.%s object for encoding %s at %#x>" % \
   111|         0|            0|            0|  0.00%|                (self.__class__.__module__, self.__class__.__qualname__,
   112|         0|            0|            0|  0.00%|                 self.name, id(self))
   113|         0|            0|            0|  0.00%|
   114|         0|            0|            0|  0.00%|class Codec:
   115|         0|            0|            0|  0.00%|
   116|         0|            0|            0|  0.00%|    """ Defines the interface for stateless encoders/decoders.
   117|         0|            0|            0|  0.00%|
   118|         0|            0|            0|  0.00%|        The .encode()/.decode() methods may use different error
   119|         0|            0|            0|  0.00%|        handling schemes by providing the errors argument. These
   120|         0|            0|            0|  0.00%|        string values are predefined:
   121|         0|            0|            0|  0.00%|
   122|         0|            0|            0|  0.00%|         'strict' - raise a ValueError error (or a subclass)
   123|         0|            0|            0|  0.00%|         'ignore' - ignore the character and continue with the next
   124|         0|            0|            0|  0.00%|         'replace' - replace with a suitable replacement character;
   125|         0|            0|            0|  0.00%|                    Python will use the official U+FFFD REPLACEMENT
   126|         0|            0|            0|  0.00%|                    CHARACTER for the builtin Unicode codecs on
   127|         0|            0|            0|  0.00%|                    decoding and '?' on encoding.
   128|         0|            0|            0|  0.00%|         'surrogateescape' - replace with private code points U+DCnn.
   129|         0|            0|            0|  0.00%|         'xmlcharrefreplace' - Replace with the appropriate XML
   130|         0|            0|            0|  0.00%|                               character reference (only for encoding).
   131|         0|            0|            0|  0.00%|         'backslashreplace'  - Replace with backslashed escape sequences.
   132|         0|            0|            0|  0.00%|         'namereplace'       - Replace with \\N{...} escape sequences
   133|         0|            0|            0|  0.00%|                               (only for encoding).
   134|         0|            0|            0|  0.00%|
   135|         0|            0|            0|  0.00%|        The set of allowed values can be extended via register_error.
   136|         0|            0|            0|  0.00%|
   137|         0|            0|            0|  0.00%|    """
   138|         0|            0|            0|  0.00%|    def encode(self, input, errors='strict'):
   139|         0|            0|            0|  0.00%|
   140|         0|            0|            0|  0.00%|        """ Encodes the object input and returns a tuple (output
   141|         0|            0|            0|  0.00%|            object, length consumed).
   142|         0|            0|            0|  0.00%|
   143|         0|            0|            0|  0.00%|            errors defines the error handling to apply. It defaults to
   144|         0|            0|            0|  0.00%|            'strict' handling.
   145|         0|            0|            0|  0.00%|
   146|         0|            0|            0|  0.00%|            The method may not store state in the Codec instance. Use
   147|         0|            0|            0|  0.00%|            StreamWriter for codecs which have to keep state in order to
   148|         0|            0|            0|  0.00%|            make encoding efficient.
   149|         0|            0|            0|  0.00%|
   150|         0|            0|            0|  0.00%|            The encoder must be able to handle zero length input and
   151|         0|            0|            0|  0.00%|            return an empty object of the output object type in this
   152|         0|            0|            0|  0.00%|            situation.
   153|         0|            0|            0|  0.00%|
   154|         0|            0|            0|  0.00%|        """
   155|         0|            0|            0|  0.00%|        raise NotImplementedError
   156|         0|            0|            0|  0.00%|
   157|         0|            0|            0|  0.00%|    def decode(self, input, errors='strict'):
   158|         0|            0|            0|  0.00%|
   159|         0|            0|            0|  0.00%|        """ Decodes the object input and returns a tuple (output
   160|         0|            0|            0|  0.00%|            object, length consumed).
   161|         0|            0|            0|  0.00%|
   162|         0|            0|            0|  0.00%|            input must be an object which provides the bf_getreadbuf
   163|         0|            0|            0|  0.00%|            buffer slot. Python strings, buffer objects and memory
   164|         0|            0|            0|  0.00%|            mapped files are examples of objects providing this slot.
   165|         0|            0|            0|  0.00%|
   166|         0|            0|            0|  0.00%|            errors defines the error handling to apply. It defaults to
   167|         0|            0|            0|  0.00%|            'strict' handling.
   168|         0|            0|            0|  0.00%|
   169|         0|            0|            0|  0.00%|            The method may not store state in the Codec instance. Use
   170|         0|            0|            0|  0.00%|            StreamReader for codecs which have to keep state in order to
   171|         0|            0|            0|  0.00%|            make decoding efficient.
   172|         0|            0|            0|  0.00%|
   173|         0|            0|            0|  0.00%|            The decoder must be able to handle zero length input and
   174|         0|            0|            0|  0.00%|            return an empty object of the output object type in this
   175|         0|            0|            0|  0.00%|            situation.
   176|         0|            0|            0|  0.00%|
   177|         0|            0|            0|  0.00%|        """
   178|         0|            0|            0|  0.00%|        raise NotImplementedError
   179|         0|            0|            0|  0.00%|
   180|         0|            0|            0|  0.00%|class IncrementalEncoder(object):
   181|         0|            0|            0|  0.00%|    """
   182|         0|            0|            0|  0.00%|    An IncrementalEncoder encodes an input in multiple steps. The input can
   183|         0|            0|            0|  0.00%|    be passed piece by piece to the encode() method. The IncrementalEncoder
   184|         0|            0|            0|  0.00%|    remembers the state of the encoding process between calls to encode().
   185|         0|            0|            0|  0.00%|    """
   186|         0|            0|            0|  0.00%|    def __init__(self, errors='strict'):
   187|         0|            0|            0|  0.00%|        """
   188|         0|            0|            0|  0.00%|        Creates an IncrementalEncoder instance.
   189|         0|            0|            0|  0.00%|
   190|         0|            0|            0|  0.00%|        The IncrementalEncoder may use different error handling schemes by
   191|         0|            0|            0|  0.00%|        providing the errors keyword argument. See the module docstring
   192|         0|            0|            0|  0.00%|        for a list of possible values.
   193|         0|            0|            0|  0.00%|        """
   194|         0|            0|            0|  0.00%|        self.errors = errors
   195|         0|            0|            0|  0.00%|        self.buffer = ""
   196|         0|            0|            0|  0.00%|
   197|         0|            0|            0|  0.00%|    def encode(self, input, final=False):
   198|         0|            0|            0|  0.00%|        """
   199|         0|            0|            0|  0.00%|        Encodes input and returns the resulting object.
   200|         0|            0|            0|  0.00%|        """
   201|         0|            0|            0|  0.00%|        raise NotImplementedError
   202|         0|            0|            0|  0.00%|
   203|         0|            0|            0|  0.00%|    def reset(self):
   204|         0|            0|            0|  0.00%|        """
   205|         0|            0|            0|  0.00%|        Resets the encoder to the initial state.
   206|         0|            0|            0|  0.00%|        """
   207|         0|            0|            0|  0.00%|
   208|         0|            0|            0|  0.00%|    def getstate(self):
   209|         0|            0|            0|  0.00%|        """
   210|         0|            0|            0|  0.00%|        Return the current state of the encoder.
   211|         0|            0|            0|  0.00%|        """
   212|         0|            0|            0|  0.00%|        return 0
   213|         0|            0|            0|  0.00%|
   214|         0|            0|            0|  0.00%|    def setstate(self, state):
   215|         0|            0|            0|  0.00%|        """
   216|         0|            0|            0|  0.00%|        Set the current state of the encoder. state must have been
   217|         0|            0|            0|  0.00%|        returned by getstate().
   218|         0|            0|            0|  0.00%|        """
   219|         0|            0|            0|  0.00%|
   220|         0|            0|            0|  0.00%|class BufferedIncrementalEncoder(IncrementalEncoder):
   221|         0|            0|            0|  0.00%|    """
   222|         0|            0|            0|  0.00%|    This subclass of IncrementalEncoder can be used as the baseclass for an
   223|         0|            0|            0|  0.00%|    incremental encoder if the encoder must keep some of the output in a
   224|         0|            0|            0|  0.00%|    buffer between calls to encode().
   225|         0|            0|            0|  0.00%|    """
   226|         0|            0|            0|  0.00%|    def __init__(self, errors='strict'):
   227|         0|            0|            0|  0.00%|        IncrementalEncoder.__init__(self, errors)
   228|         0|            0|            0|  0.00%|        # unencoded input that is kept between calls to encode()
   229|         0|            0|            0|  0.00%|        self.buffer = ""
   230|         0|            0|            0|  0.00%|
   231|         0|            0|            0|  0.00%|    def _buffer_encode(self, input, errors, final):
   232|         0|            0|            0|  0.00%|        # Overwrite this method in subclasses: It must encode input
   233|         0|            0|            0|  0.00%|        # and return an (output, length consumed) tuple
   234|         0|            0|            0|  0.00%|        raise NotImplementedError
   235|         0|            0|            0|  0.00%|
   236|         0|            0|            0|  0.00%|    def encode(self, input, final=False):
   237|         0|            0|            0|  0.00%|        # encode input (taking the buffer into account)
   238|         0|            0|            0|  0.00%|        data = self.buffer + input
   239|         0|            0|            0|  0.00%|        (result, consumed) = self._buffer_encode(data, self.errors, final)
   240|         0|            0|            0|  0.00%|        # keep unencoded input until the next call
   241|         0|            0|            0|  0.00%|        self.buffer = data[consumed:]
   242|         0|            0|            0|  0.00%|        return result
   243|         0|            0|            0|  0.00%|
   244|         0|            0|            0|  0.00%|    def reset(self):
   245|         0|            0|            0|  0.00%|        IncrementalEncoder.reset(self)
   246|         0|            0|            0|  0.00%|        self.buffer = ""
   247|         0|            0|            0|  0.00%|
   248|         0|            0|            0|  0.00%|    def getstate(self):
   249|         0|            0|            0|  0.00%|        return self.buffer or 0
   250|         0|            0|            0|  0.00%|
   251|         0|            0|            0|  0.00%|    def setstate(self, state):
   252|         0|            0|            0|  0.00%|        self.buffer = state or ""
   253|         0|            0|            0|  0.00%|
   254|         0|            0|            0|  0.00%|class IncrementalDecoder(object):
   255|         0|            0|            0|  0.00%|    """
   256|         0|            0|            0|  0.00%|    An IncrementalDecoder decodes an input in multiple steps. The input can
   257|         0|            0|            0|  0.00%|    be passed piece by piece to the decode() method. The IncrementalDecoder
   258|         0|            0|            0|  0.00%|    remembers the state of the decoding process between calls to decode().
   259|         0|            0|            0|  0.00%|    """
   260|         3|            0|            0|  0.00%|    def __init__(self, errors='strict'):
   261|         0|            0|            0|  0.00%|        """
   262|         0|            0|            0|  0.00%|        Create an IncrementalDecoder instance.
   263|         0|            0|            0|  0.00%|
   264|         0|            0|            0|  0.00%|        The IncrementalDecoder may use different error handling schemes by
   265|         0|            0|            0|  0.00%|        providing the errors keyword argument. See the module docstring
   266|         0|            0|            0|  0.00%|        for a list of possible values.
   267|         0|            0|            0|  0.00%|        """
   268|         3|            0|            0|  0.00%|        self.errors = errors
   269|         0|            0|            0|  0.00%|
   270|         0|            0|            0|  0.00%|    def decode(self, input, final=False):
   271|         0|            0|            0|  0.00%|        """
   272|         0|            0|            0|  0.00%|        Decode input and returns the resulting object.
   273|         0|            0|            0|  0.00%|        """
   274|         0|            0|            0|  0.00%|        raise NotImplementedError
   275|         0|            0|            0|  0.00%|
   276|         0|            0|            0|  0.00%|    def reset(self):
   277|         0|            0|            0|  0.00%|        """
   278|         0|            0|            0|  0.00%|        Reset the decoder to the initial state.
   279|         0|            0|            0|  0.00%|        """
   280|         0|            0|            0|  0.00%|
   281|         0|            0|            0|  0.00%|    def getstate(self):
   282|         0|            0|            0|  0.00%|        """
   283|         0|            0|            0|  0.00%|        Return the current state of the decoder.
   284|         0|            0|            0|  0.00%|
   285|         0|            0|            0|  0.00%|        This must be a (buffered_input, additional_state_info) tuple.
   286|         0|            0|            0|  0.00%|        buffered_input must be a bytes object containing bytes that
   287|         0|            0|            0|  0.00%|        were passed to decode() that have not yet been converted.
   288|         0|            0|            0|  0.00%|        additional_state_info must be a non-negative integer
   289|         0|            0|            0|  0.00%|        representing the state of the decoder WITHOUT yet having
   290|         0|            0|            0|  0.00%|        processed the contents of buffered_input.  In the initial state
   291|         0|            0|            0|  0.00%|        and after reset(), getstate() must return (b"", 0).
   292|         0|            0|            0|  0.00%|        """
   293|         0|            0|            0|  0.00%|        return (b"", 0)
   294|         0|            0|            0|  0.00%|
   295|         0|            0|            0|  0.00%|    def setstate(self, state):
   296|         0|            0|            0|  0.00%|        """
   297|         0|            0|            0|  0.00%|        Set the current state of the decoder.
   298|         0|            0|            0|  0.00%|
   299|         0|            0|            0|  0.00%|        state must have been returned by getstate().  The effect of
   300|         0|            0|            0|  0.00%|        setstate((b"", 0)) must be equivalent to reset().
   301|         0|            0|            0|  0.00%|        """
   302|         0|            0|            0|  0.00%|
   303|         0|            0|            0|  0.00%|class BufferedIncrementalDecoder(IncrementalDecoder):
   304|         0|            0|            0|  0.00%|    """
   305|         0|            0|            0|  0.00%|    This subclass of IncrementalDecoder can be used as the baseclass for an
   306|         0|            0|            0|  0.00%|    incremental decoder if the decoder must be able to handle incomplete
   307|         0|            0|            0|  0.00%|    byte sequences.
   308|         0|            0|            0|  0.00%|    """
   309|         1|            0|            0|  0.00%|    def __init__(self, errors='strict'):
   310|         1|            0|            0|  0.00%|        IncrementalDecoder.__init__(self, errors)
(call)|         1|            0|            0|  0.00%|# C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.8_3.8.1520.0_x64__qbz5n2kfra8p0\lib\codecs.py:260 __init__
   311|         0|            0|            0|  0.00%|        # undecoded input that is kept between calls to decode()
   312|         1|            0|            0|  0.00%|        self.buffer = b""
   313|         0|            0|            0|  0.00%|
   314|         0|            0|            0|  0.00%|    def _buffer_decode(self, input, errors, final):
   315|         0|            0|            0|  0.00%|        # Overwrite this method in subclasses: It must decode input
   316|         0|            0|            0|  0.00%|        # and return an (output, length consumed) tuple
   317|         0|            0|            0|  0.00%|        raise NotImplementedError
   318|         0|            0|            0|  0.00%|
   319|        13|            0|            0|  0.00%|    def decode(self, input, final=False):
   320|         0|            0|            0|  0.00%|        # decode input (taking the buffer into account)
   321|        13|            0|            0|  0.00%|        data = self.buffer + input
   322|        13|            0|            0|  0.00%|        (result, consumed) = self._buffer_decode(data, self.errors, final)
   323|         0|            0|            0|  0.00%|        # keep undecoded input until the next call
   324|        13|            0|            0|  0.00%|        self.buffer = data[consumed:]
   325|        13|            0|            0|  0.00%|        return result
   326|         0|            0|            0|  0.00%|
   327|         0|            0|            0|  0.00%|    def reset(self):
   328|         0|            0|            0|  0.00%|        IncrementalDecoder.reset(self)
   329|         0|            0|            0|  0.00%|        self.buffer = b""
   330|         0|            0|            0|  0.00%|
   331|         0|            0|            0|  0.00%|    def getstate(self):
   332|         0|            0|            0|  0.00%|        # additional state info is always 0
   333|         0|            0|            0|  0.00%|        return (self.buffer, 0)
   334|         0|            0|            0|  0.00%|
   335|         0|            0|            0|  0.00%|    def setstate(self, state):
   336|         0|            0|            0|  0.00%|        # ignore additional state info
   337|         0|            0|            0|  0.00%|        self.buffer = state[0]
   338|         0|            0|            0|  0.00%|
   339|         0|            0|            0|  0.00%|#
   340|         0|            0|            0|  0.00%|# The StreamWriter and StreamReader class provide generic working
   341|         0|            0|            0|  0.00%|# interfaces which can be used to implement new encoding submodules
   342|         0|            0|            0|  0.00%|# very easily. See encodings/utf_8.py for an example on how this is
   343|         0|            0|            0|  0.00%|# done.
   344|         0|            0|            0|  0.00%|#
   345|         0|            0|            0|  0.00%|
   346|         0|            0|            0|  0.00%|class StreamWriter(Codec):
   347|         0|            0|            0|  0.00%|
   348|         0|            0|            0|  0.00%|    def __init__(self, stream, errors='strict'):
   349|         0|            0|            0|  0.00%|
   350|         0|            0|            0|  0.00%|        """ Creates a StreamWriter instance.
   351|         0|            0|            0|  0.00%|
   352|         0|            0|            0|  0.00%|            stream must be a file-like object open for writing.
   353|         0|            0|            0|  0.00%|
   354|         0|            0|            0|  0.00%|            The StreamWriter may use different error handling
   355|         0|            0|            0|  0.00%|            schemes by providing the errors keyword argument. These
   356|         0|            0|            0|  0.00%|            parameters are predefined:
   357|         0|            0|            0|  0.00%|
   358|         0|            0|            0|  0.00%|             'strict' - raise a ValueError (or a subclass)
   359|         0|            0|            0|  0.00%|             'ignore' - ignore the character and continue with the next
   360|         0|            0|            0|  0.00%|             'replace'- replace with a suitable replacement character
   361|         0|            0|            0|  0.00%|             'xmlcharrefreplace' - Replace with the appropriate XML
   362|         0|            0|            0|  0.00%|                                   character reference.
   363|         0|            0|            0|  0.00%|             'backslashreplace'  - Replace with backslashed escape
   364|         0|            0|            0|  0.00%|                                   sequences.
   365|         0|            0|            0|  0.00%|             'namereplace'       - Replace with \\N{...} escape sequences.
   366|         0|            0|            0|  0.00%|
   367|         0|            0|            0|  0.00%|            The set of allowed parameter values can be extended via
   368|         0|            0|            0|  0.00%|            register_error.
   369|         0|            0|            0|  0.00%|        """
   370|         0|            0|            0|  0.00%|        self.stream = stream
   371|         0|            0|            0|  0.00%|        self.errors = errors
   372|         0|            0|            0|  0.00%|
   373|         0|            0|            0|  0.00%|    def write(self, object):
   374|         0|            0|            0|  0.00%|
   375|         0|            0|            0|  0.00%|        """ Writes the object's contents encoded to self.stream.
   376|         0|            0|            0|  0.00%|        """
   377|         0|            0|            0|  0.00%|        data, consumed = self.encode(object, self.errors)
   378|         0|            0|            0|  0.00%|        self.stream.write(data)
   379|         0|            0|            0|  0.00%|
   380|         0|            0|            0|  0.00%|    def writelines(self, list):
   381|         0|            0|            0|  0.00%|
   382|         0|            0|            0|  0.00%|        """ Writes the concatenated list of strings to the stream
   383|         0|            0|            0|  0.00%|            using .write().
   384|         0|            0|            0|  0.00%|        """
   385|         0|            0|            0|  0.00%|        self.write(''.join(list))
   386|         0|            0|            0|  0.00%|
   387|         0|            0|            0|  0.00%|    def reset(self):
   388|         0|            0|            0|  0.00%|
   389|         0|            0|            0|  0.00%|        """ Flushes and resets the codec buffers used for keeping state.
   390|         0|            0|            0|  0.00%|
   391|         0|            0|            0|  0.00%|            Calling this method should ensure that the data on the
   392|         0|            0|            0|  0.00%|            output is put into a clean state, that allows appending
   393|         0|            0|            0|  0.00%|            of new fresh data without having to rescan the whole
   394|         0|            0|            0|  0.00%|            stream to recover state.
   395|         0|            0|            0|  0.00%|
   396|         0|            0|            0|  0.00%|        """
   397|         0|            0|            0|  0.00%|        pass
   398|         0|            0|            0|  0.00%|
   399|         0|            0|            0|  0.00%|    def seek(self, offset, whence=0):
   400|         0|            0|            0|  0.00%|        self.stream.seek(offset, whence)
   401|         0|            0|            0|  0.00%|        if whence == 0 and offset == 0:
   402|         0|            0|            0|  0.00%|            self.reset()
   403|         0|            0|            0|  0.00%|
   404|         0|            0|            0|  0.00%|    def __getattr__(self, name,
   405|         0|            0|            0|  0.00%|                    getattr=getattr):
   406|         0|            0|            0|  0.00%|
   407|         0|            0|            0|  0.00%|        """ Inherit all other methods from the underlying stream.
   408|         0|            0|            0|  0.00%|        """
   409|         0|            0|            0|  0.00%|        return getattr(self.stream, name)
   410|         0|            0|            0|  0.00%|
   411|         0|            0|            0|  0.00%|    def __enter__(self):
   412|         0|            0|            0|  0.00%|        return self
   413|         0|            0|            0|  0.00%|
   414|         0|            0|            0|  0.00%|    def __exit__(self, type, value, tb):
   415|         0|            0|            0|  0.00%|        self.stream.close()
   416|         0|            0|            0|  0.00%|
   417|         0|            0|            0|  0.00%|###
   418|         0|            0|            0|  0.00%|
   419|         0|            0|            0|  0.00%|class StreamReader(Codec):
   420|         0|            0|            0|  0.00%|
   421|         0|            0|            0|  0.00%|    charbuffertype = str
   422|         0|            0|            0|  0.00%|
   423|         0|            0|            0|  0.00%|    def __init__(self, stream, errors='strict'):
   424|         0|            0|            0|  0.00%|
   425|         0|            0|            0|  0.00%|        """ Creates a StreamReader instance.
   426|         0|            0|            0|  0.00%|
   427|         0|            0|            0|  0.00%|            stream must be a file-like object open for reading.
   428|         0|            0|            0|  0.00%|
   429|         0|            0|            0|  0.00%|            The StreamReader may use different error handling
   430|         0|            0|            0|  0.00%|            schemes by providing the errors keyword argument. These
   431|         0|            0|            0|  0.00%|            parameters are predefined:
   432|         0|            0|            0|  0.00%|
   433|         0|            0|            0|  0.00%|             'strict' - raise a ValueError (or a subclass)
   434|         0|            0|            0|  0.00%|             'ignore' - ignore the character and continue with the next
   435|         0|            0|            0|  0.00%|             'replace'- replace with a suitable replacement character
   436|         0|            0|            0|  0.00%|             'backslashreplace' - Replace with backslashed escape sequences;
   437|         0|            0|            0|  0.00%|
   438|         0|            0|            0|  0.00%|            The set of allowed parameter values can be extended via
   439|         0|            0|            0|  0.00%|            register_error.
   440|         0|            0|            0|  0.00%|        """
   441|         0|            0|            0|  0.00%|        self.stream = stream
   442|         0|            0|            0|  0.00%|        self.errors = errors
   443|         0|            0|            0|  0.00%|        self.bytebuffer = b""
   444|         0|            0|            0|  0.00%|        self._empty_charbuffer = self.charbuffertype()
   445|         0|            0|            0|  0.00%|        self.charbuffer = self._empty_charbuffer
   446|         0|            0|            0|  0.00%|        self.linebuffer = None
   447|         0|            0|            0|  0.00%|
   448|         0|            0|            0|  0.00%|    def decode(self, input, errors='strict'):
   449|         0|            0|            0|  0.00%|        raise NotImplementedError
   450|         0|            0|            0|  0.00%|
   451|         0|            0|            0|  0.00%|    def read(self, size=-1, chars=-1, firstline=False):
   452|         0|            0|            0|  0.00%|
   453|         0|            0|            0|  0.00%|        """ Decodes data from the stream self.stream and returns the
   454|         0|            0|            0|  0.00%|            resulting object.
   455|         0|            0|            0|  0.00%|
   456|         0|            0|            0|  0.00%|            chars indicates the number of decoded code points or bytes to
   457|         0|            0|            0|  0.00%|            return. read() will never return more data than requested,
   458|         0|            0|            0|  0.00%|            but it might return less, if there is not enough available.
   459|         0|            0|            0|  0.00%|
   460|         0|            0|            0|  0.00%|            size indicates the approximate maximum number of decoded
   461|         0|            0|            0|  0.00%|            bytes or code points to read for decoding. The decoder
   462|         0|            0|            0|  0.00%|            can modify this setting as appropriate. The default value
   463|         0|            0|            0|  0.00%|            -1 indicates to read and decode as much as possible.  size
   464|         0|            0|            0|  0.00%|            is intended to prevent having to decode huge files in one
   465|         0|            0|            0|  0.00%|            step.
   466|         0|            0|            0|  0.00%|
   467|         0|            0|            0|  0.00%|            If firstline is true, and a UnicodeDecodeError happens
   468|         0|            0|            0|  0.00%|            after the first line terminator in the input only the first line
   469|         0|            0|            0|  0.00%|            will be returned, the rest of the input will be kept until the
   470|         0|            0|            0|  0.00%|            next call to read().
   471|         0|            0|            0|  0.00%|
   472|         0|            0|            0|  0.00%|            The method should use a greedy read strategy, meaning that
   473|         0|            0|            0|  0.00%|            it should read as much data as is allowed within the
   474|         0|            0|            0|  0.00%|            definition of the encoding and the given size, e.g.  if
   475|         0|            0|            0|  0.00%|            optional encoding endings or state markers are available
   476|         0|            0|            0|  0.00%|            on the stream, these should be read too.
   477|         0|            0|            0|  0.00%|        """
   478|         0|            0|            0|  0.00%|        # If we have lines cached, first merge them back into characters
   479|         0|            0|            0|  0.00%|        if self.linebuffer:
   480|         0|            0|            0|  0.00%|            self.charbuffer = self._empty_charbuffer.join(self.linebuffer)
   481|         0|            0|            0|  0.00%|            self.linebuffer = None
   482|         0|            0|            0|  0.00%|
   483|         0|            0|            0|  0.00%|        if chars < 0:
   484|         0|            0|            0|  0.00%|            # For compatibility with other read() methods that take a
   485|         0|            0|            0|  0.00%|            # single argument
   486|         0|            0|            0|  0.00%|            chars = size
   487|         0|            0|            0|  0.00%|
   488|         0|            0|            0|  0.00%|        # read until we get the required number of characters (if available)
   489|         0|            0|            0|  0.00%|        while True:
   490|         0|            0|            0|  0.00%|            # can the request be satisfied from the character buffer?
   491|         0|            0|            0|  0.00%|            if chars >= 0:
   492|         0|            0|            0|  0.00%|                if len(self.charbuffer) >= chars:
   493|         0|            0|            0|  0.00%|                    break
   494|         0|            0|            0|  0.00%|            # we need more data
   495|         0|            0|            0|  0.00%|            if size < 0:
   496|         0|            0|            0|  0.00%|                newdata = self.stream.read()
   497|         0|            0|            0|  0.00%|            else:
   498|         0|            0|            0|  0.00%|                newdata = self.stream.read(size)
   499|         0|            0|            0|  0.00%|            # decode bytes (those remaining from the last call included)
   500|         0|            0|            0|  0.00%|            data = self.bytebuffer + newdata
   501|         0|            0|            0|  0.00%|            if not data:
   502|         0|            0|            0|  0.00%|                break
   503|         0|            0|            0|  0.00%|            try:
   504|         0|            0|            0|  0.00%|                newchars, decodedbytes = self.decode(data, self.errors)
   505|         0|            0|            0|  0.00%|            except UnicodeDecodeError as exc:
   506|         0|            0|            0|  0.00%|                if firstline:
   507|         0|            0|            0|  0.00%|                    newchars, decodedbytes = \
   508|         0|            0|            0|  0.00%|                        self.decode(data[:exc.start], self.errors)
   509|         0|            0|            0|  0.00%|                    lines = newchars.splitlines(keepends=True)
   510|         0|            0|            0|  0.00%|                    if len(lines)<=1:
   511|         0|            0|            0|  0.00%|                        raise
   512|         0|            0|            0|  0.00%|                else:
   513|         0|            0|            0|  0.00%|                    raise
   514|         0|            0|            0|  0.00%|            # keep undecoded bytes until the next call
   515|         0|            0|            0|  0.00%|            self.bytebuffer = data[decodedbytes:]
   516|         0|            0|            0|  0.00%|            # put new characters in the character buffer
   517|         0|            0|            0|  0.00%|            self.charbuffer += newchars
   518|         0|            0|            0|  0.00%|            # there was no data available
   519|         0|            0|            0|  0.00%|            if not newdata:
   520|         0|            0|            0|  0.00%|                break
   521|         0|            0|            0|  0.00%|        if chars < 0:
   522|         0|            0|            0|  0.00%|            # Return everything we've got
   523|         0|            0|            0|  0.00%|            result = self.charbuffer
   524|         0|            0|            0|  0.00%|            self.charbuffer = self._empty_charbuffer
   525|         0|            0|            0|  0.00%|        else:
   526|         0|            0|            0|  0.00%|            # Return the first chars characters
   527|         0|            0|            0|  0.00%|            result = self.charbuffer[:chars]
   528|         0|            0|            0|  0.00%|            self.charbuffer = self.charbuffer[chars:]
   529|         0|            0|            0|  0.00%|        return result
   530|         0|            0|            0|  0.00%|
   531|         0|            0|            0|  0.00%|    def readline(self, size=None, keepends=True):
   532|         0|            0|            0|  0.00%|
   533|         0|            0|            0|  0.00%|        """ Read one line from the input stream and return the
   534|         0|            0|            0|  0.00%|            decoded data.
   535|         0|            0|            0|  0.00%|
   536|         0|            0|            0|  0.00%|            size, if given, is passed as size argument to the
   537|         0|            0|            0|  0.00%|            read() method.
   538|         0|            0|            0|  0.00%|
   539|         0|            0|            0|  0.00%|        """
   540|         0|            0|            0|  0.00%|        # If we have lines cached from an earlier read, return
   541|         0|            0|            0|  0.00%|        # them unconditionally
   542|         0|            0|            0|  0.00%|        if self.linebuffer:
   543|         0|            0|            0|  0.00%|            line = self.linebuffer[0]
   544|         0|            0|            0|  0.00%|            del self.linebuffer[0]
   545|         0|            0|            0|  0.00%|            if len(self.linebuffer) == 1:
   546|         0|            0|            0|  0.00%|                # revert to charbuffer mode; we might need more data
   547|         0|            0|            0|  0.00%|                # next time
   548|         0|            0|            0|  0.00%|                self.charbuffer = self.linebuffer[0]
   549|         0|            0|            0|  0.00%|                self.linebuffer = None
   550|         0|            0|            0|  0.00%|            if not keepends:
   551|         0|            0|            0|  0.00%|                line = line.splitlines(keepends=False)[0]
   552|         0|            0|            0|  0.00%|            return line
   553|         0|            0|            0|  0.00%|
   554|         0|            0|            0|  0.00%|        readsize = size or 72
   555|         0|            0|            0|  0.00%|        line = self._empty_charbuffer
   556|         0|            0|            0|  0.00%|        # If size is given, we call read() only once
   557|         0|            0|            0|  0.00%|        while True:
   558|         0|            0|            0|  0.00%|            data = self.read(readsize, firstline=True)
   559|         0|            0|            0|  0.00%|            if data:
   560|         0|            0|            0|  0.00%|                # If we're at a "\r" read one extra character (which might
   561|         0|            0|            0|  0.00%|                # be a "\n") to get a proper line ending. If the stream is
   562|         0|            0|            0|  0.00%|                # temporarily exhausted we return the wrong line ending.
   563|         0|            0|            0|  0.00%|                if (isinstance(data, str) and data.endswith("\r")) or \
   564|         0|            0|            0|  0.00%|                   (isinstance(data, bytes) and data.endswith(b"\r")):
   565|         0|            0|            0|  0.00%|                    data += self.read(size=1, chars=1)
   566|         0|            0|            0|  0.00%|
   567|         0|            0|            0|  0.00%|            line += data
   568|         0|            0|            0|  0.00%|            lines = line.splitlines(keepends=True)
   569|         0|            0|            0|  0.00%|            if lines:
   570|         0|            0|            0|  0.00%|                if len(lines) > 1:
   571|         0|            0|            0|  0.00%|                    # More than one line result; the first line is a full line
   572|         0|            0|            0|  0.00%|                    # to return
   573|         0|            0|            0|  0.00%|                    line = lines[0]
   574|         0|            0|            0|  0.00%|                    del lines[0]
   575|         0|            0|            0|  0.00%|                    if len(lines) > 1:
   576|         0|            0|            0|  0.00%|                        # cache the remaining lines
   577|         0|            0|            0|  0.00%|                        lines[-1] += self.charbuffer
   578|         0|            0|            0|  0.00%|                        self.linebuffer = lines
   579|         0|            0|            0|  0.00%|                        self.charbuffer = None
   580|         0|            0|            0|  0.00%|                    else:
   581|         0|            0|            0|  0.00%|                        # only one remaining line, put it back into charbuffer
   582|         0|            0|            0|  0.00%|                        self.charbuffer = lines[0] + self.charbuffer
   583|         0|            0|            0|  0.00%|                    if not keepends:
   584|         0|            0|            0|  0.00%|                        line = line.splitlines(keepends=False)[0]
   585|         0|            0|            0|  0.00%|                    break
   586|         0|            0|            0|  0.00%|                line0withend = lines[0]
   587|         0|            0|            0|  0.00%|                line0withoutend = lines[0].splitlines(keepends=False)[0]
   588|         0|            0|            0|  0.00%|                if line0withend != line0withoutend: # We really have a line end
   589|         0|            0|            0|  0.00%|                    # Put the rest back together and keep it until the next call
   590|         0|            0|            0|  0.00%|                    self.charbuffer = self._empty_charbuffer.join(lines[1:]) + \
   591|         0|            0|            0|  0.00%|                                      self.charbuffer
   592|         0|            0|            0|  0.00%|                    if keepends:
   593|         0|            0|            0|  0.00%|                        line = line0withend
   594|         0|            0|            0|  0.00%|                    else:
   595|         0|            0|            0|  0.00%|                        line = line0withoutend
   596|         0|            0|            0|  0.00%|                    break
   597|         0|            0|            0|  0.00%|            # we didn't get anything or this was our only try
   598|         0|            0|            0|  0.00%|            if not data or size is not None:
   599|         0|            0|            0|  0.00%|                if line and not keepends:
   600|         0|            0|            0|  0.00%|                    line = line.splitlines(keepends=False)[0]
   601|         0|            0|            0|  0.00%|                break
   602|         0|            0|            0|  0.00%|            if readsize < 8000:
   603|         0|            0|            0|  0.00%|                readsize *= 2
   604|         0|            0|            0|  0.00%|        return line
   605|         0|            0|            0|  0.00%|
   606|         0|            0|            0|  0.00%|    def readlines(self, sizehint=None, keepends=True):
   607|         0|            0|            0|  0.00%|
   608|         0|            0|            0|  0.00%|        """ Read all lines available on the input stream
   609|         0|            0|            0|  0.00%|            and return them as a list.
   610|         0|            0|            0|  0.00%|
   611|         0|            0|            0|  0.00%|            Line breaks are implemented using the codec's decoder
   612|         0|            0|            0|  0.00%|            method and are included in the list entries.
   613|         0|            0|            0|  0.00%|
   614|         0|            0|            0|  0.00%|            sizehint, if given, is ignored since there is no efficient
   615|         0|            0|            0|  0.00%|            way to finding the true end-of-line.
   616|         0|            0|            0|  0.00%|
   617|         0|            0|            0|  0.00%|        """
   618|         0|            0|            0|  0.00%|        data = self.read()
   619|         0|            0|            0|  0.00%|        return data.splitlines(keepends)
   620|         0|            0|            0|  0.00%|
   621|         0|            0|            0|  0.00%|    def reset(self):
   622|         0|            0|            0|  0.00%|
   623|         0|            0|            0|  0.00%|        """ Resets the codec buffers used for keeping state.
   624|         0|            0|            0|  0.00%|
   625|         0|            0|            0|  0.00%|            Note that no stream repositioning should take place.
   626|         0|            0|            0|  0.00%|            This method is primarily intended to be able to recover
   627|         0|            0|            0|  0.00%|            from decoding errors.
   628|         0|            0|            0|  0.00%|
   629|         0|            0|            0|  0.00%|        """
   630|         0|            0|            0|  0.00%|        self.bytebuffer = b""
   631|         0|            0|            0|  0.00%|        self.charbuffer = self._empty_charbuffer
   632|         0|            0|            0|  0.00%|        self.linebuffer = None
   633|         0|            0|            0|  0.00%|
   634|         0|            0|            0|  0.00%|    def seek(self, offset, whence=0):
   635|         0|            0|            0|  0.00%|        """ Set the input stream's current position.
   636|         0|            0|            0|  0.00%|
   637|         0|            0|            0|  0.00%|            Resets the codec buffers used for keeping state.
   638|         0|            0|            0|  0.00%|        """
   639|         0|            0|            0|  0.00%|        self.stream.seek(offset, whence)
   640|         0|            0|            0|  0.00%|        self.reset()
   641|         0|            0|            0|  0.00%|
   642|         0|            0|            0|  0.00%|    def __next__(self):
   643|         0|            0|            0|  0.00%|
   644|         0|            0|            0|  0.00%|        """ Return the next decoded line from the input stream."""
   645|         0|            0|            0|  0.00%|        line = self.readline()
   646|         0|            0|            0|  0.00%|        if line:
   647|         0|            0|            0|  0.00%|            return line
   648|         0|            0|            0|  0.00%|        raise StopIteration
   649|         0|            0|            0|  0.00%|
   650|         0|            0|            0|  0.00%|    def __iter__(self):
   651|         0|            0|            0|  0.00%|        return self
   652|         0|            0|            0|  0.00%|
   653|         0|            0|            0|  0.00%|    def __getattr__(self, name,
   654|         0|            0|            0|  0.00%|                    getattr=getattr):
   655|         0|            0|            0|  0.00%|
   656|         0|            0|            0|  0.00%|        """ Inherit all other methods from the underlying stream.
   657|         0|            0|            0|  0.00%|        """
   658|         0|            0|            0|  0.00%|        return getattr(self.stream, name)
   659|         0|            0|            0|  0.00%|
   660|         0|            0|            0|  0.00%|    def __enter__(self):
   661|         0|            0|            0|  0.00%|        return self
   662|         0|            0|            0|  0.00%|
   663|         0|            0|            0|  0.00%|    def __exit__(self, type, value, tb):
   664|         0|            0|            0|  0.00%|        self.stream.close()
   665|         0|            0|            0|  0.00%|
   666|         0|            0|            0|  0.00%|###
   667|         0|            0|            0|  0.00%|
   668|         0|            0|            0|  0.00%|class StreamReaderWriter:
   669|         0|            0|            0|  0.00%|
   670|         0|            0|            0|  0.00%|    """ StreamReaderWriter instances allow wrapping streams which
   671|         0|            0|            0|  0.00%|        work in both read and write modes.
   672|         0|            0|            0|  0.00%|
   673|         0|            0|            0|  0.00%|        The design is such that one can use the factory functions
   674|         0|            0|            0|  0.00%|        returned by the codec.lookup() function to construct the
   675|         0|            0|            0|  0.00%|        instance.
   676|         0|            0|            0|  0.00%|
   677|         0|            0|            0|  0.00%|    """
   678|         0|            0|            0|  0.00%|    # Optional attributes set by the file wrappers below
   679|         0|            0|            0|  0.00%|    encoding = 'unknown'
   680|         0|            0|            0|  0.00%|
   681|         0|            0|            0|  0.00%|    def __init__(self, stream, Reader, Writer, errors='strict'):
   682|         0|            0|            0|  0.00%|
   683|         0|            0|            0|  0.00%|        """ Creates a StreamReaderWriter instance.
   684|         0|            0|            0|  0.00%|
   685|         0|            0|            0|  0.00%|            stream must be a Stream-like object.
   686|         0|            0|            0|  0.00%|
   687|         0|            0|            0|  0.00%|            Reader, Writer must be factory functions or classes
   688|         0|            0|            0|  0.00%|            providing the StreamReader, StreamWriter interface resp.
   689|         0|            0|            0|  0.00%|
   690|         0|            0|            0|  0.00%|            Error handling is done in the same way as defined for the
   691|         0|            0|            0|  0.00%|            StreamWriter/Readers.
   692|         0|            0|            0|  0.00%|
   693|         0|            0|            0|  0.00%|        """
   694|         0|            0|            0|  0.00%|        self.stream = stream
   695|         0|            0|            0|  0.00%|        self.reader = Reader(stream, errors)
   696|         0|            0|            0|  0.00%|        self.writer = Writer(stream, errors)
   697|         0|            0|            0|  0.00%|        self.errors = errors
   698|         0|            0|            0|  0.00%|
   699|         0|            0|            0|  0.00%|    def read(self, size=-1):
   700|         0|            0|            0|  0.00%|
   701|         0|            0|            0|  0.00%|        return self.reader.read(size)
   702|         0|            0|            0|  0.00%|
   703|         0|            0|            0|  0.00%|    def readline(self, size=None):
   704|         0|            0|            0|  0.00%|
   705|         0|            0|            0|  0.00%|        return self.reader.readline(size)
   706|         0|            0|            0|  0.00%|
   707|         0|            0|            0|  0.00%|    def readlines(self, sizehint=None):
   708|         0|            0|            0|  0.00%|
   709|         0|            0|            0|  0.00%|        return self.reader.readlines(sizehint)
   710|         0|            0|            0|  0.00%|
   711|         0|            0|            0|  0.00%|    def __next__(self):
   712|         0|            0|            0|  0.00%|
   713|         0|            0|            0|  0.00%|        """ Return the next decoded line from the input stream."""
   714|         0|            0|            0|  0.00%|        return next(self.reader)
   715|         0|            0|            0|  0.00%|
   716|         0|            0|            0|  0.00%|    def __iter__(self):
   717|         0|            0|            0|  0.00%|        return self
   718|         0|            0|            0|  0.00%|
   719|         0|            0|            0|  0.00%|    def write(self, data):
   720|         0|            0|            0|  0.00%|
   721|         0|            0|            0|  0.00%|        return self.writer.write(data)
   722|         0|            0|            0|  0.00%|
   723|         0|            0|            0|  0.00%|    def writelines(self, list):
   724|         0|            0|            0|  0.00%|
   725|         0|            0|            0|  0.00%|        return self.writer.writelines(list)
   726|         0|            0|            0|  0.00%|
   727|         0|            0|            0|  0.00%|    def reset(self):
   728|         0|            0|            0|  0.00%|
   729|         0|            0|            0|  0.00%|        self.reader.reset()
   730|         0|            0|            0|  0.00%|        self.writer.reset()
   731|         0|            0|            0|  0.00%|
   732|         0|            0|            0|  0.00%|    def seek(self, offset, whence=0):
   733|         0|            0|            0|  0.00%|        self.stream.seek(offset, whence)
   734|         0|            0|            0|  0.00%|        self.reader.reset()
   735|         0|            0|            0|  0.00%|        if whence == 0 and offset == 0:
   736|         0|            0|            0|  0.00%|            self.writer.reset()
   737|         0|            0|            0|  0.00%|
   738|         0|            0|            0|  0.00%|    def __getattr__(self, name,
   739|         0|            0|            0|  0.00%|                    getattr=getattr):
   740|         0|            0|            0|  0.00%|
   741|         0|            0|            0|  0.00%|        """ Inherit all other methods from the underlying stream.
   742|         0|            0|            0|  0.00%|        """
   743|         0|            0|            0|  0.00%|        return getattr(self.stream, name)
   744|         0|            0|            0|  0.00%|
   745|         0|            0|            0|  0.00%|    # these are needed to make "with StreamReaderWriter(...)" work properly
   746|         0|            0|            0|  0.00%|
   747|         0|            0|            0|  0.00%|    def __enter__(self):
   748|         0|            0|            0|  0.00%|        return self
   749|         0|            0|            0|  0.00%|
   750|         0|            0|            0|  0.00%|    def __exit__(self, type, value, tb):
   751|         0|            0|            0|  0.00%|        self.stream.close()
   752|         0|            0|            0|  0.00%|
   753|         0|            0|            0|  0.00%|###
   754|         0|            0|            0|  0.00%|
   755|         0|            0|            0|  0.00%|class StreamRecoder:
   756|         0|            0|            0|  0.00%|
   757|         0|            0|            0|  0.00%|    """ StreamRecoder instances translate data from one encoding to another.
   758|         0|            0|            0|  0.00%|
   759|         0|            0|            0|  0.00%|        They use the complete set of APIs returned by the
   760|         0|            0|            0|  0.00%|        codecs.lookup() function to implement their task.
   761|         0|            0|            0|  0.00%|
   762|         0|            0|            0|  0.00%|        Data written to the StreamRecoder is first decoded into an
   763|         0|            0|            0|  0.00%|        intermediate format (depending on the "decode" codec) and then
   764|         0|            0|            0|  0.00%|        written to the underlying stream using an instance of the provided
   765|         0|            0|            0|  0.00%|        Writer class.
   766|         0|            0|            0|  0.00%|
   767|         0|            0|            0|  0.00%|        In the other direction, data is read from the underlying stream using
   768|         0|            0|            0|  0.00%|        a Reader instance and then encoded and returned to the caller.
   769|         0|            0|            0|  0.00%|
   770|         0|            0|            0|  0.00%|    """
   771|         0|            0|            0|  0.00%|    # Optional attributes set by the file wrappers below
   772|         0|            0|            0|  0.00%|    data_encoding = 'unknown'
   773|         0|            0|            0|  0.00%|    file_encoding = 'unknown'
   774|         0|            0|            0|  0.00%|
   775|         0|            0|            0|  0.00%|    def __init__(self, stream, encode, decode, Reader, Writer,
   776|         0|            0|            0|  0.00%|                 errors='strict'):
   777|         0|            0|            0|  0.00%|
   778|         0|            0|            0|  0.00%|        """ Creates a StreamRecoder instance which implements a two-way
   779|         0|            0|            0|  0.00%|            conversion: encode and decode work on the frontend (the
   780|         0|            0|            0|  0.00%|            data visible to .read() and .write()) while Reader and Writer
   781|         0|            0|            0|  0.00%|            work on the backend (the data in stream).
   782|         0|            0|            0|  0.00%|
   783|         0|            0|            0|  0.00%|            You can use these objects to do transparent
   784|         0|            0|            0|  0.00%|            transcodings from e.g. latin-1 to utf-8 and back.
   785|         0|            0|            0|  0.00%|
   786|         0|            0|            0|  0.00%|            stream must be a file-like object.
   787|         0|            0|            0|  0.00%|
   788|         0|            0|            0|  0.00%|            encode and decode must adhere to the Codec interface; Reader and
   789|         0|            0|            0|  0.00%|            Writer must be factory functions or classes providing the
   790|         0|            0|            0|  0.00%|            StreamReader and StreamWriter interfaces resp.
   791|         0|            0|            0|  0.00%|
   792|         0|            0|            0|  0.00%|            Error handling is done in the same way as defined for the
   793|         0|            0|            0|  0.00%|            StreamWriter/Readers.
   794|         0|            0|            0|  0.00%|
   795|         0|            0|            0|  0.00%|        """
   796|         0|            0|            0|  0.00%|        self.stream = stream
   797|         0|            0|            0|  0.00%|        self.encode = encode
   798|         0|            0|            0|  0.00%|        self.decode = decode
   799|         0|            0|            0|  0.00%|        self.reader = Reader(stream, errors)
   800|         0|            0|            0|  0.00%|        self.writer = Writer(stream, errors)
   801|         0|            0|            0|  0.00%|        self.errors = errors
   802|         0|            0|            0|  0.00%|
   803|         0|            0|            0|  0.00%|    def read(self, size=-1):
   804|         0|            0|            0|  0.00%|
   805|         0|            0|            0|  0.00%|        data = self.reader.read(size)
   806|         0|            0|            0|  0.00%|        data, bytesencoded = self.encode(data, self.errors)
   807|         0|            0|            0|  0.00%|        return data
   808|         0|            0|            0|  0.00%|
   809|         0|            0|            0|  0.00%|    def readline(self, size=None):
   810|         0|            0|            0|  0.00%|
   811|         0|            0|            0|  0.00%|        if size is None:
   812|         0|            0|            0|  0.00%|            data = self.reader.readline()
   813|         0|            0|            0|  0.00%|        else:
   814|         0|            0|            0|  0.00%|            data = self.reader.readline(size)
   815|         0|            0|            0|  0.00%|        data, bytesencoded = self.encode(data, self.errors)
   816|         0|            0|            0|  0.00%|        return data
   817|         0|            0|            0|  0.00%|
   818|         0|            0|            0|  0.00%|    def readlines(self, sizehint=None):
   819|         0|            0|            0|  0.00%|
   820|         0|            0|            0|  0.00%|        data = self.reader.read()
   821|         0|            0|            0|  0.00%|        data, bytesencoded = self.encode(data, self.errors)
   822|         0|            0|            0|  0.00%|        return data.splitlines(keepends=True)
   823|         0|            0|            0|  0.00%|
   824|         0|            0|            0|  0.00%|    def __next__(self):
   825|         0|            0|            0|  0.00%|
   826|         0|            0|            0|  0.00%|        """ Return the next decoded line from the input stream."""
   827|         0|            0|            0|  0.00%|        data = next(self.reader)
   828|         0|            0|            0|  0.00%|        data, bytesencoded = self.encode(data, self.errors)
   829|         0|            0|            0|  0.00%|        return data
   830|         0|            0|            0|  0.00%|
   831|         0|            0|            0|  0.00%|    def __iter__(self):
   832|         0|            0|            0|  0.00%|        return self
   833|         0|            0|            0|  0.00%|
   834|         0|            0|            0|  0.00%|    def write(self, data):
   835|         0|            0|            0|  0.00%|
   836|         0|            0|            0|  0.00%|        data, bytesdecoded = self.decode(data, self.errors)
   837|         0|            0|            0|  0.00%|        return self.writer.write(data)
   838|         0|            0|            0|  0.00%|
   839|         0|            0|            0|  0.00%|    def writelines(self, list):
   840|         0|            0|            0|  0.00%|
   841|         0|            0|            0|  0.00%|        data = b''.join(list)
   842|         0|            0|            0|  0.00%|        data, bytesdecoded = self.decode(data, self.errors)
   843|         0|            0|            0|  0.00%|        return self.writer.write(data)
   844|         0|            0|            0|  0.00%|
   845|         0|            0|            0|  0.00%|    def reset(self):
   846|         0|            0|            0|  0.00%|
   847|         0|            0|            0|  0.00%|        self.reader.reset()
   848|         0|            0|            0|  0.00%|        self.writer.reset()
   849|         0|            0|            0|  0.00%|
   850|         0|            0|            0|  0.00%|    def seek(self, offset, whence=0):
   851|         0|            0|            0|  0.00%|        # Seeks must be propagated to both the readers and writers
   852|         0|            0|            0|  0.00%|        # as they might need to reset their internal buffers.
   853|         0|            0|            0|  0.00%|        self.reader.seek(offset, whence)
   854|         0|            0|            0|  0.00%|        self.writer.seek(offset, whence)
   855|         0|            0|            0|  0.00%|
   856|         0|            0|            0|  0.00%|    def __getattr__(self, name,
   857|         0|            0|            0|  0.00%|                    getattr=getattr):
   858|         0|            0|            0|  0.00%|
   859|         0|            0|            0|  0.00%|        """ Inherit all other methods from the underlying stream.
   860|         0|            0|            0|  0.00%|        """
   861|         0|            0|            0|  0.00%|        return getattr(self.stream, name)
   862|         0|            0|            0|  0.00%|
   863|         0|            0|            0|  0.00%|    def __enter__(self):
   864|         0|            0|            0|  0.00%|        return self
   865|         0|            0|            0|  0.00%|
   866|         0|            0|            0|  0.00%|    def __exit__(self, type, value, tb):
   867|         0|            0|            0|  0.00%|        self.stream.close()
   868|         0|            0|            0|  0.00%|
   869|         0|            0|            0|  0.00%|### Shortcuts
   870|         0|            0|            0|  0.00%|
   871|         0|            0|            0|  0.00%|def open(filename, mode='r', encoding=None, errors='strict', buffering=-1):
   872|         0|            0|            0|  0.00%|
   873|         0|            0|            0|  0.00%|    """ Open an encoded file using the given mode and return
   874|         0|            0|            0|  0.00%|        a wrapped version providing transparent encoding/decoding.
   875|         0|            0|            0|  0.00%|
   876|         0|            0|            0|  0.00%|        Note: The wrapped version will only accept the object format
   877|         0|            0|            0|  0.00%|        defined by the codecs, i.e. Unicode objects for most builtin
   878|         0|            0|            0|  0.00%|        codecs. Output is also codec dependent and will usually be
   879|         0|            0|            0|  0.00%|        Unicode as well.
   880|         0|            0|            0|  0.00%|
   881|         0|            0|            0|  0.00%|        Underlying encoded files are always opened in binary mode.
   882|         0|            0|            0|  0.00%|        The default file mode is 'r', meaning to open the file in read mode.
   883|         0|            0|            0|  0.00%|
   884|         0|            0|            0|  0.00%|        encoding specifies the encoding which is to be used for the
   885|         0|            0|            0|  0.00%|        file.
   886|         0|            0|            0|  0.00%|
   887|         0|            0|            0|  0.00%|        errors may be given to define the error handling. It defaults
   888|         0|            0|            0|  0.00%|        to 'strict' which causes ValueErrors to be raised in case an
   889|         0|            0|            0|  0.00%|        encoding error occurs.
   890|         0|            0|            0|  0.00%|
   891|         0|            0|            0|  0.00%|        buffering has the same meaning as for the builtin open() API.
   892|         0|            0|            0|  0.00%|        It defaults to -1 which means that the default buffer size will
   893|         0|            0|            0|  0.00%|        be used.
   894|         0|            0|            0|  0.00%|
   895|         0|            0|            0|  0.00%|        The returned wrapped file object provides an extra attribute
   896|         0|            0|            0|  0.00%|        .encoding which allows querying the used encoding. This
   897|         0|            0|            0|  0.00%|        attribute is only available if an encoding was specified as
   898|         0|            0|            0|  0.00%|        parameter.
   899|         0|            0|            0|  0.00%|
   900|         0|            0|            0|  0.00%|    """
   901|         0|            0|            0|  0.00%|    if encoding is not None and \
   902|         0|            0|            0|  0.00%|       'b' not in mode:
   903|         0|            0|            0|  0.00%|        # Force opening of the file in binary mode
   904|         0|            0|            0|  0.00%|        mode = mode + 'b'
   905|         0|            0|            0|  0.00%|    file = builtins.open(filename, mode, buffering)
   906|         0|            0|            0|  0.00%|    if encoding is None:
   907|         0|            0|            0|  0.00%|        return file
   908|         0|            0|            0|  0.00%|
   909|         0|            0|            0|  0.00%|    try:
   910|         0|            0|            0|  0.00%|        info = lookup(encoding)
   911|         0|            0|            0|  0.00%|        srw = StreamReaderWriter(file, info.streamreader, info.streamwriter, errors)
   912|         0|            0|            0|  0.00%|        # Add attributes to simplify introspection
   913|         0|            0|            0|  0.00%|        srw.encoding = encoding
   914|         0|            0|            0|  0.00%|        return srw
   915|         0|            0|            0|  0.00%|    except:
   916|         0|            0|            0|  0.00%|        file.close()
   917|         0|            0|            0|  0.00%|        raise
   918|         0|            0|            0|  0.00%|
   919|         0|            0|            0|  0.00%|def EncodedFile(file, data_encoding, file_encoding=None, errors='strict'):
   920|         0|            0|            0|  0.00%|
   921|         0|            0|            0|  0.00%|    """ Return a wrapped version of file which provides transparent
   922|         0|            0|            0|  0.00%|        encoding translation.
   923|         0|            0|            0|  0.00%|
   924|         0|            0|            0|  0.00%|        Data written to the wrapped file is decoded according
   925|         0|            0|            0|  0.00%|        to the given data_encoding and then encoded to the underlying
   926|         0|            0|            0|  0.00%|        file using file_encoding. The intermediate data type
   927|         0|            0|            0|  0.00%|        will usually be Unicode but depends on the specified codecs.
   928|         0|            0|            0|  0.00%|
   929|         0|            0|            0|  0.00%|        Bytes read from the file are decoded using file_encoding and then
   930|         0|            0|            0|  0.00%|        passed back to the caller encoded using data_encoding.
   931|         0|            0|            0|  0.00%|
   932|         0|            0|            0|  0.00%|        If file_encoding is not given, it defaults to data_encoding.
   933|         0|            0|            0|  0.00%|
   934|         0|            0|            0|  0.00%|        errors may be given to define the error handling. It defaults
   935|         0|            0|            0|  0.00%|        to 'strict' which causes ValueErrors to be raised in case an
   936|         0|            0|            0|  0.00%|        encoding error occurs.
   937|         0|            0|            0|  0.00%|
   938|         0|            0|            0|  0.00%|        The returned wrapped file object provides two extra attributes
   939|         0|            0|            0|  0.00%|        .data_encoding and .file_encoding which reflect the given
   940|         0|            0|            0|  0.00%|        parameters of the same name. The attributes can be used for
   941|         0|            0|            0|  0.00%|        introspection by Python programs.
   942|         0|            0|            0|  0.00%|
   943|         0|            0|            0|  0.00%|    """
   944|         0|            0|            0|  0.00%|    if file_encoding is None:
   945|         0|            0|            0|  0.00%|        file_encoding = data_encoding
   946|         0|            0|            0|  0.00%|    data_info = lookup(data_encoding)
   947|         0|            0|            0|  0.00%|    file_info = lookup(file_encoding)
   948|         0|            0|            0|  0.00%|    sr = StreamRecoder(file, data_info.encode, data_info.decode,
   949|         0|            0|            0|  0.00%|                       file_info.streamreader, file_info.streamwriter, errors)
   950|         0|            0|            0|  0.00%|    # Add attributes to simplify introspection
   951|         0|            0|            0|  0.00%|    sr.data_encoding = data_encoding
   952|         0|            0|            0|  0.00%|    sr.file_encoding = file_encoding
   953|         0|            0|            0|  0.00%|    return sr
   954|         0|            0|            0|  0.00%|
   955|         0|            0|            0|  0.00%|### Helpers for codec lookup
   956|         0|            0|            0|  0.00%|
   957|         0|            0|            0|  0.00%|def getencoder(encoding):
   958|         0|            0|            0|  0.00%|
   959|         0|            0|            0|  0.00%|    """ Lookup up the codec for the given encoding and return
   960|         0|            0|            0|  0.00%|        its encoder function.
   961|         0|            0|            0|  0.00%|
   962|         0|            0|            0|  0.00%|        Raises a LookupError in case the encoding cannot be found.
   963|         0|            0|            0|  0.00%|
   964|         0|            0|            0|  0.00%|    """
   965|         0|            0|            0|  0.00%|    return lookup(encoding).encode
   966|         0|            0|            0|  0.00%|
   967|         0|            0|            0|  0.00%|def getdecoder(encoding):
   968|         0|            0|            0|  0.00%|
   969|         0|            0|            0|  0.00%|    """ Lookup up the codec for the given encoding and return
   970|         0|            0|            0|  0.00%|        its decoder function.
   971|         0|            0|            0|  0.00%|
   972|         0|            0|            0|  0.00%|        Raises a LookupError in case the encoding cannot be found.
   973|         0|            0|            0|  0.00%|
   974|         0|            0|            0|  0.00%|    """
   975|         0|            0|            0|  0.00%|    return lookup(encoding).decode
   976|         0|            0|            0|  0.00%|
   977|         0|            0|            0|  0.00%|def getincrementalencoder(encoding):
   978|         0|            0|            0|  0.00%|
   979|         0|            0|            0|  0.00%|    """ Lookup up the codec for the given encoding and return
   980|         0|            0|            0|  0.00%|        its IncrementalEncoder class or factory function.
   981|         0|            0|            0|  0.00%|
   982|         0|            0|            0|  0.00%|        Raises a LookupError in case the encoding cannot be found
   983|         0|            0|            0|  0.00%|        or the codecs doesn't provide an incremental encoder.
   984|         0|            0|            0|  0.00%|
   985|         0|            0|            0|  0.00%|    """
   986|         0|            0|            0|  0.00%|    encoder = lookup(encoding).incrementalencoder
   987|         0|            0|            0|  0.00%|    if encoder is None:
   988|         0|            0|            0|  0.00%|        raise LookupError(encoding)
   989|         0|            0|            0|  0.00%|    return encoder
   990|         0|            0|            0|  0.00%|
   991|         0|            0|            0|  0.00%|def getincrementaldecoder(encoding):
   992|         0|            0|            0|  0.00%|
   993|         0|            0|            0|  0.00%|    """ Lookup up the codec for the given encoding and return
   994|         0|            0|            0|  0.00%|        its IncrementalDecoder class or factory function.
   995|         0|            0|            0|  0.00%|
   996|         0|            0|            0|  0.00%|        Raises a LookupError in case the encoding cannot be found
   997|         0|            0|            0|  0.00%|        or the codecs doesn't provide an incremental decoder.
   998|         0|            0|            0|  0.00%|
   999|         0|            0|            0|  0.00%|    """
  1000|         0|            0|            0|  0.00%|    decoder = lookup(encoding).incrementaldecoder
  1001|         0|            0|            0|  0.00%|    if decoder is None:
  1002|         0|            0|            0|  0.00%|        raise LookupError(encoding)
  1003|         0|            0|            0|  0.00%|    return decoder
  1004|         0|            0|            0|  0.00%|
  1005|         0|            0|            0|  0.00%|def getreader(encoding):
  1006|         0|            0|            0|  0.00%|
  1007|         0|            0|            0|  0.00%|    """ Lookup up the codec for the given encoding and return
  1008|         0|            0|            0|  0.00%|        its StreamReader class or factory function.
  1009|         0|            0|            0|  0.00%|
  1010|         0|            0|            0|  0.00%|        Raises a LookupError in case the encoding cannot be found.
  1011|         0|            0|            0|  0.00%|
  1012|         0|            0|            0|  0.00%|    """
  1013|         0|            0|            0|  0.00%|    return lookup(encoding).streamreader
  1014|         0|            0|            0|  0.00%|
  1015|         0|            0|            0|  0.00%|def getwriter(encoding):
  1016|         0|            0|            0|  0.00%|
  1017|         0|            0|            0|  0.00%|    """ Lookup up the codec for the given encoding and return
  1018|         0|            0|            0|  0.00%|        its StreamWriter class or factory function.
  1019|         0|            0|            0|  0.00%|
  1020|         0|            0|            0|  0.00%|        Raises a LookupError in case the encoding cannot be found.
  1021|         0|            0|            0|  0.00%|
  1022|         0|            0|            0|  0.00%|    """
  1023|         0|            0|            0|  0.00%|    return lookup(encoding).streamwriter
  1024|         0|            0|            0|  0.00%|
  1025|         0|            0|            0|  0.00%|def iterencode(iterator, encoding, errors='strict', **kwargs):
  1026|         0|            0|            0|  0.00%|    """
  1027|         0|            0|            0|  0.00%|    Encoding iterator.
  1028|         0|            0|            0|  0.00%|
  1029|         0|            0|            0|  0.00%|    Encodes the input strings from the iterator using an IncrementalEncoder.
  1030|         0|            0|            0|  0.00%|
  1031|         0|            0|            0|  0.00%|    errors and kwargs are passed through to the IncrementalEncoder
  1032|         0|            0|            0|  0.00%|    constructor.
  1033|         0|            0|            0|  0.00%|    """
  1034|         0|            0|            0|  0.00%|    encoder = getincrementalencoder(encoding)(errors, **kwargs)
  1035|         0|            0|            0|  0.00%|    for input in iterator:
  1036|         0|            0|            0|  0.00%|        output = encoder.encode(input)
  1037|         0|            0|            0|  0.00%|        if output:
  1038|         0|            0|            0|  0.00%|            yield output
  1039|         0|            0|            0|  0.00%|    output = encoder.encode("", True)
  1040|         0|            0|            0|  0.00%|    if output:
  1041|         0|            0|            0|  0.00%|        yield output
  1042|         0|            0|            0|  0.00%|
  1043|         0|            0|            0|  0.00%|def iterdecode(iterator, encoding, errors='strict', **kwargs):
  1044|         0|            0|            0|  0.00%|    """
  1045|         0|            0|            0|  0.00%|    Decoding iterator.
  1046|         0|            0|            0|  0.00%|
  1047|         0|            0|            0|  0.00%|    Decodes the input strings from the iterator using an IncrementalDecoder.
  1048|         0|            0|            0|  0.00%|
  1049|         0|            0|            0|  0.00%|    errors and kwargs are passed through to the IncrementalDecoder
  1050|         0|            0|            0|  0.00%|    constructor.
  1051|         0|            0|            0|  0.00%|    """
  1052|         0|            0|            0|  0.00%|    decoder = getincrementaldecoder(encoding)(errors, **kwargs)
  1053|         0|            0|            0|  0.00%|    for input in iterator:
  1054|         0|            0|            0|  0.00%|        output = decoder.decode(input)
  1055|         0|            0|            0|  0.00%|        if output:
  1056|         0|            0|            0|  0.00%|            yield output
  1057|         0|            0|            0|  0.00%|    output = decoder.decode(b"", True)
  1058|         0|            0|            0|  0.00%|    if output:
  1059|         0|            0|            0|  0.00%|        yield output
  1060|         0|            0|            0|  0.00%|
  1061|         0|            0|            0|  0.00%|### Helpers for charmap-based codecs
  1062|         0|            0|            0|  0.00%|
  1063|         0|            0|            0|  0.00%|def make_identity_dict(rng):
  1064|         0|            0|            0|  0.00%|
  1065|         0|            0|            0|  0.00%|    """ make_identity_dict(rng) -> dict
  1066|         0|            0|            0|  0.00%|
  1067|         0|            0|            0|  0.00%|        Return a dictionary where elements of the rng sequence are
  1068|         0|            0|            0|  0.00%|        mapped to themselves.
  1069|         0|            0|            0|  0.00%|
  1070|         0|            0|            0|  0.00%|    """
  1071|         0|            0|            0|  0.00%|    return {i:i for i in rng}
  1072|         0|            0|            0|  0.00%|
  1073|         0|            0|            0|  0.00%|def make_encoding_map(decoding_map):
  1074|         0|            0|            0|  0.00%|
  1075|         0|            0|            0|  0.00%|    """ Creates an encoding map from a decoding map.
  1076|         0|            0|            0|  0.00%|
  1077|         0|            0|            0|  0.00%|        If a target mapping in the decoding map occurs multiple
  1078|         0|            0|            0|  0.00%|        times, then that target is mapped to None (undefined mapping),
  1079|         0|            0|            0|  0.00%|        causing an exception when encountered by the charmap codec
  1080|         0|            0|            0|  0.00%|        during translation.
  1081|         0|            0|            0|  0.00%|
  1082|         0|            0|            0|  0.00%|        One example where this happens is cp875.py which decodes
  1083|         0|            0|            0|  0.00%|        multiple character to \\u001a.
  1084|         0|            0|            0|  0.00%|
  1085|         0|            0|            0|  0.00%|    """
  1086|         0|            0|            0|  0.00%|    m = {}
  1087|         0|            0|            0|  0.00%|    for k,v in decoding_map.items():
  1088|         0|            0|            0|  0.00%|        if not v in m:
  1089|         0|            0|            0|  0.00%|            m[v] = k
  1090|         0|            0|            0|  0.00%|        else:
  1091|         0|            0|            0|  0.00%|            m[v] = None
  1092|         0|            0|            0|  0.00%|    return m
  1093|         0|            0|            0|  0.00%|
  1094|         0|            0|            0|  0.00%|### error handlers
  1095|         0|            0|            0|  0.00%|
  1096|         0|            0|            0|  0.00%|try:
  1097|         0|            0|            0|  0.00%|    strict_errors = lookup_error("strict")
  1098|         0|            0|            0|  0.00%|    ignore_errors = lookup_error("ignore")
  1099|         0|            0|            0|  0.00%|    replace_errors = lookup_error("replace")
  1100|         0|            0|            0|  0.00%|    xmlcharrefreplace_errors = lookup_error("xmlcharrefreplace")
  1101|         0|            0|            0|  0.00%|    backslashreplace_errors = lookup_error("backslashreplace")
  1102|         0|            0|            0|  0.00%|    namereplace_errors = lookup_error("namereplace")
  1103|         0|            0|            0|  0.00%|except LookupError:
  1104|         0|            0|            0|  0.00%|    # In --disable-unicode builds, these error handler are missing
  1105|         0|            0|            0|  0.00%|    strict_errors = None
  1106|         0|            0|            0|  0.00%|    ignore_errors = None
  1107|         0|            0|            0|  0.00%|    replace_errors = None
  1108|         0|            0|            0|  0.00%|    xmlcharrefreplace_errors = None
  1109|         0|            0|            0|  0.00%|    backslashreplace_errors = None
  1110|         0|            0|            0|  0.00%|    namereplace_errors = None
  1111|         0|            0|            0|  0.00%|
  1112|         0|            0|            0|  0.00%|# Tell modulefinder that using codecs probably needs the encodings
  1113|         0|            0|            0|  0.00%|# package
  1114|         0|            0|            0|  0.00%|_false = 0
  1115|         0|            0|            0|  0.00%|if _false:
  1116|         0|            0|            0|  0.00%|    import encodings
  1117|         0|            0|            0|  0.00%|
  1118|         0|            0|            0|  0.00%|### Tests
  1119|         0|            0|            0|  0.00%|
  1120|         0|            0|            0|  0.00%|if __name__ == '__main__':
  1121|         0|            0|            0|  0.00%|
  1122|         0|            0|            0|  0.00%|    # Make stdout translate Latin-1 output into UTF-8 output
  1123|         0|            0|            0|  0.00%|    sys.stdout = EncodedFile(sys.stdout, 'latin-1', 'utf-8')
  1124|         0|            0|            0|  0.00%|
  1125|         0|            0|            0|  0.00%|    # Have stdin translate Latin-1 input into UTF-8 input
  1126|         0|            0|            0|  0.00%|    sys.stdin = EncodedFile(sys.stdin, 'utf-8', 'latin-1')
File: solver.py
File duration: 0s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|from CNF import CNF_Formula
     2|         0|            0|            0|  0.00%|from DPLL import DPLL
     3|         0|            0|            0|  0.00%|import sys
     4|         0|            0|            0|  0.00%|import time
     5|         0|            0|            0|  0.00%|
     6|         0|            0|            0|  0.00%|class SAT_Solver():
     7|         0|            0|            0|  0.00%|
     8|         1|            0|            0|  0.00%|    def __init__(self):
     9|         1|            0|            0|  0.00%|        self.CNF = CNF_Formula()
(call)|         1|            0|            0|  0.00%|# C:\Users\bdode\Documents\Website_projects\SAT\working_learning\SAT-44\code\classes\CNF.py:13 __init__
    10|         1|            0|            0|  0.00%|        sys.setrecursionlimit(5000)
    11|         0|            0|            0|  0.00%|        # Use this in the future to counter iterations
    12|         1|            0|            0|  0.00%|        self.iterations_counter = 0
    13|         0|            0|            0|  0.00%|
    14|         0|            0|            0|  0.00%|        # Are we currently backtracking?
    15|         1|            0|            0|  0.00%|        self.backtracking = False
    16|         1|            0|            0|  0.00%|        self.backtracking_depth = None
    17|         0|            0|            0|  0.00%|
    18|         1|            0|            0|  0.00%|    def load_dimacs_file(self, file):
    19|         1|            0|            0|  0.00%|        self.CNF.load_dimacs_file(file)
(call)|         1|     0.419337|     0.419337|  2.46%|# C:\Users\bdode\Documents\Website_projects\SAT\working_learning\SAT-44\code\classes\CNF.py:399 load_dimacs_file
    20|         0|            0|            0|  0.00%|
    21|         1|            0|            0|  0.00%|    def load_sudoku_file(self, file):
    22|         1|            0|            0|  0.00%|        self.CNF.load_sudoku_file(file)
(call)|         1|      9.97283|      9.97283| 58.56%|# C:\Users\bdode\Documents\Website_projects\SAT\working_learning\SAT-44\code\classes\CNF.py:410 load_sudoku_file
    23|         0|            0|            0|  0.00%|
    24|         0|            0|            0|  0.00%|    def print_CNF_status(self):
    25|         0|            0|            0|  0.00%|        self.CNF.print_status()
    26|         0|            0|            0|  0.00%|
    27|         1|            0|            0|  0.00%|    def solve_CNF(self):
    28|         1|            0|            0|  0.00%|        self.CNF.remove_pure_literals()
(call)|         1|   0.00400376|   0.00400376|  0.02%|# C:\Users\bdode\Documents\Website_projects\SAT\working_learning\SAT-44\code\classes\CNF.py:213 remove_pure_literals
    29|         1|            0|            0|  0.00%|        self.CNF.remove_unit_clauses()
(call)|         1|      4.52228|      4.52228| 26.55%|# C:\Users\bdode\Documents\Website_projects\SAT\working_learning\SAT-44\code\classes\CNF.py:185 remove_unit_clauses
    30|         0|            0|            0|  0.00%|
    31|         0|            0|            0|  0.00%|
    32|         1|            0|            0|  0.00%|        result = DPLL(self)
(call)|         1|      2.10423|      2.10423| 12.36%|# C:\Users\bdode\Documents\Website_projects\SAT\working_learning\SAT-44\code\classes\DPLL.py:5 DPLL
    33|         1|            0|            0|  0.00%|        if result == "SAT":
    34|         1|            0|            0|  0.00%|            print("\nSAT!")
(call)|         2|            0|            0|  0.00%|# C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.8_3.8.1520.0_x64__qbz5n2kfra8p0\lib\encodings\cp1252.py:18 encode
    35|         1|            0|            0|  0.00%|            self.print_answer()
(call)|         1|   0.00600529|   0.00600529|  0.04%|# solver.py:39 print_answer
    36|         0|            0|            0|  0.00%|        else:
    37|         0|            0|            0|  0.00%|            print(result)
    38|         0|            0|            0|  0.00%|
    39|         1|            0|            0|  0.00%|    def print_answer(self):
    40|         1|            0|            0|  0.00%|        self.CNF.print_answer()
(call)|         1|   0.00600529|   0.00600529|  0.04%|# C:\Users\bdode\Documents\Website_projects\SAT\working_learning\SAT-44\code\classes\CNF.py:481 print_answer
    41|         0|            0|            0|  0.00%|
    42|         1|            0|            0|  0.00%|def main():
    43|         1|            0|            0|  0.00%|    Solver = SAT_Solver()
(call)|         1|            0|            0|  0.00%|# solver.py:8 __init__
    44|         1|            0|            0|  0.00%|    Solver.load_dimacs_file("files/rules.txt")
(call)|         1|     0.419337|     0.419337|  2.46%|# solver.py:18 load_dimacs_file
    45|         1|            0|            0|  0.00%|    Solver.load_sudoku_file("files/9x9.txt")
(call)|         1|      9.97283|      9.97283| 58.56%|# solver.py:21 load_sudoku_file
    46|         0|            0|            0|  0.00%|    # Solver.load_sudoku_file("files/hard.txt")
    47|         1|            0|            0|  0.00%|    print()
(call)|         1|            0|            0|  0.00%|# C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.8_3.8.1520.0_x64__qbz5n2kfra8p0\lib\encodings\cp1252.py:18 encode
    48|         1|            0|            0|  0.00%|    before = time.time()
    49|         1|            0|            0|  0.00%|    Solver.solve_CNF()
(call)|         1|      6.63652|      6.63652| 38.97%|# solver.py:27 solve_CNF
    50|         0|            0|            0|  0.00%|    # Solver.CNF.print_total_status()
    51|         1|            0|            0|  0.00%|    print("Time:", time.time() - before)
(call)|         4|            0|            0|  0.00%|# C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.8_3.8.1520.0_x64__qbz5n2kfra8p0\lib\encodings\cp1252.py:18 encode
    52|         0|            0|            0|  0.00%|
    53|         0|            0|            0|  0.00%|if __name__ == "__main__":
    54|         0|            0|            0|  0.00%|    import pprofile
    55|         0|            0|            0|  0.00%|    profiler = pprofile.Profile()
    56|         0|            0|            0|  0.00%|    with profiler:
    57|         0|            0|            0|  0.00%|        main()
(call)|         1|      17.0287|      17.0287| 99.99%|# solver.py:42 main
    58|         0|            0|            0|  0.00%|
    59|         0|            0|            0|  0.00%|    profiler.print_stats()
    60|         0|            0|            0|  0.00%|
File: C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.8_3.8.1520.0_x64__qbz5n2kfra8p0\lib\linecache.py
File duration: 0s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""Cache lines from Python source files.
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|This is intended to read lines from modules imported -- hence if a filename
     4|         0|            0|            0|  0.00%|is not found, it will look down the module search path for a file by
     5|         0|            0|            0|  0.00%|that name.
     6|         0|            0|            0|  0.00%|"""
     7|         0|            0|            0|  0.00%|
     8|         0|            0|            0|  0.00%|import functools
     9|         0|            0|            0|  0.00%|import sys
    10|         0|            0|            0|  0.00%|import os
    11|         0|            0|            0|  0.00%|import tokenize
    12|         0|            0|            0|  0.00%|
    13|         0|            0|            0|  0.00%|__all__ = ["getline", "clearcache", "checkcache"]
    14|         0|            0|            0|  0.00%|
    15|         1|            0|            0|  0.00%|def getline(filename, lineno, module_globals=None):
    16|         1|            0|            0|  0.00%|    lines = getlines(filename, module_globals)
(call)|         1|   0.00100112|   0.00100112|  0.01%|# C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.8_3.8.1520.0_x64__qbz5n2kfra8p0\lib\linecache.py:37 getlines
    17|         1|            0|            0|  0.00%|    if 1 <= lineno <= len(lines):
    18|         1|            0|            0|  0.00%|        return lines[lineno-1]
    19|         0|            0|            0|  0.00%|    else:
    20|         0|            0|            0|  0.00%|        return ''
    21|         0|            0|            0|  0.00%|
    22|         0|            0|            0|  0.00%|
    23|         0|            0|            0|  0.00%|# The cache
    24|         0|            0|            0|  0.00%|
    25|         0|            0|            0|  0.00%|# The cache. Maps filenames to either a thunk which will provide source code,
    26|         0|            0|            0|  0.00%|# or a tuple (size, mtime, lines, fullname) once loaded.
    27|         0|            0|            0|  0.00%|cache = {}
    28|         0|            0|            0|  0.00%|
    29|         0|            0|            0|  0.00%|
    30|         0|            0|            0|  0.00%|def clearcache():
    31|         0|            0|            0|  0.00%|    """Clear the cache entirely."""
    32|         0|            0|            0|  0.00%|
    33|         0|            0|            0|  0.00%|    global cache
    34|         0|            0|            0|  0.00%|    cache = {}
    35|         0|            0|            0|  0.00%|
    36|         0|            0|            0|  0.00%|
    37|         1|            0|            0|  0.00%|def getlines(filename, module_globals=None):
    38|         0|            0|            0|  0.00%|    """Get the lines for a Python source file from the cache.
    39|         0|            0|            0|  0.00%|    Update the cache if it doesn't contain an entry for this file already."""
    40|         0|            0|            0|  0.00%|
    41|         1|            0|            0|  0.00%|    if filename in cache:
    42|         0|            0|            0|  0.00%|        entry = cache[filename]
    43|         0|            0|            0|  0.00%|        if len(entry) != 1:
    44|         0|            0|            0|  0.00%|            return cache[filename][2]
    45|         0|            0|            0|  0.00%|
    46|         1|            0|            0|  0.00%|    try:
    47|         1|            0|            0|  0.00%|        return updatecache(filename, module_globals)
(call)|         1|   0.00100112|   0.00100112|  0.01%|# C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.8_3.8.1520.0_x64__qbz5n2kfra8p0\lib\linecache.py:82 updatecache
    48|         0|            0|            0|  0.00%|    except MemoryError:
    49|         0|            0|            0|  0.00%|        clearcache()
    50|         0|            0|            0|  0.00%|        return []
    51|         0|            0|            0|  0.00%|
    52|         0|            0|            0|  0.00%|
    53|         0|            0|            0|  0.00%|def checkcache(filename=None):
    54|         0|            0|            0|  0.00%|    """Discard cache entries that are out of date.
    55|         0|            0|            0|  0.00%|    (This is not checked upon each call!)"""
    56|         0|            0|            0|  0.00%|
    57|         0|            0|            0|  0.00%|    if filename is None:
    58|         0|            0|            0|  0.00%|        filenames = list(cache.keys())
    59|         0|            0|            0|  0.00%|    else:
    60|         0|            0|            0|  0.00%|        if filename in cache:
    61|         0|            0|            0|  0.00%|            filenames = [filename]
    62|         0|            0|            0|  0.00%|        else:
    63|         0|            0|            0|  0.00%|            return
    64|         0|            0|            0|  0.00%|
    65|         0|            0|            0|  0.00%|    for filename in filenames:
    66|         0|            0|            0|  0.00%|        entry = cache[filename]
    67|         0|            0|            0|  0.00%|        if len(entry) == 1:
    68|         0|            0|            0|  0.00%|            # lazy cache entry, leave it lazy.
    69|         0|            0|            0|  0.00%|            continue
    70|         0|            0|            0|  0.00%|        size, mtime, lines, fullname = entry
    71|         0|            0|            0|  0.00%|        if mtime is None:
    72|         0|            0|            0|  0.00%|            continue   # no-op for files loaded via a __loader__
    73|         0|            0|            0|  0.00%|        try:
    74|         0|            0|            0|  0.00%|            stat = os.stat(fullname)
    75|         0|            0|            0|  0.00%|        except OSError:
    76|         0|            0|            0|  0.00%|            cache.pop(filename, None)
    77|         0|            0|            0|  0.00%|            continue
    78|         0|            0|            0|  0.00%|        if size != stat.st_size or mtime != stat.st_mtime:
    79|         0|            0|            0|  0.00%|            cache.pop(filename, None)
    80|         0|            0|            0|  0.00%|
    81|         0|            0|            0|  0.00%|
    82|         1|            0|            0|  0.00%|def updatecache(filename, module_globals=None):
    83|         0|            0|            0|  0.00%|    """Update a cache entry and return its list of lines.
    84|         0|            0|            0|  0.00%|    If something's wrong, print a message, discard the cache entry,
    85|         0|            0|            0|  0.00%|    and return an empty list."""
    86|         0|            0|            0|  0.00%|
    87|         1|            0|            0|  0.00%|    if filename in cache:
    88|         0|            0|            0|  0.00%|        if len(cache[filename]) != 1:
    89|         0|            0|            0|  0.00%|            cache.pop(filename, None)
    90|         1|            0|            0|  0.00%|    if not filename or (filename.startswith('<') and filename.endswith('>')):
    91|         0|            0|            0|  0.00%|        return []
    92|         0|            0|            0|  0.00%|
    93|         1|            0|            0|  0.00%|    fullname = filename
    94|         1|            0|            0|  0.00%|    try:
    95|         1|            0|            0|  0.00%|        stat = os.stat(fullname)
    96|         0|            0|            0|  0.00%|    except OSError:
    97|         0|            0|            0|  0.00%|        basename = filename
    98|         0|            0|            0|  0.00%|
    99|         0|            0|            0|  0.00%|        # Realise a lazy loader based lookup if there is one
   100|         0|            0|            0|  0.00%|        # otherwise try to lookup right now.
   101|         0|            0|            0|  0.00%|        if lazycache(filename, module_globals):
   102|         0|            0|            0|  0.00%|            try:
   103|         0|            0|            0|  0.00%|                data = cache[filename][0]()
   104|         0|            0|            0|  0.00%|            except (ImportError, OSError):
   105|         0|            0|            0|  0.00%|                pass
   106|         0|            0|            0|  0.00%|            else:
   107|         0|            0|            0|  0.00%|                if data is None:
   108|         0|            0|            0|  0.00%|                    # No luck, the PEP302 loader cannot find the source
   109|         0|            0|            0|  0.00%|                    # for this module.
   110|         0|            0|            0|  0.00%|                    return []
   111|         0|            0|            0|  0.00%|                cache[filename] = (
   112|         0|            0|            0|  0.00%|                    len(data), None,
   113|         0|            0|            0|  0.00%|                    [line+'\n' for line in data.splitlines()], fullname
   114|         0|            0|            0|  0.00%|                )
   115|         0|            0|            0|  0.00%|                return cache[filename][2]
   116|         0|            0|            0|  0.00%|
   117|         0|            0|            0|  0.00%|        # Try looking through the module search path, which is only useful
   118|         0|            0|            0|  0.00%|        # when handling a relative filename.
   119|         0|            0|            0|  0.00%|        if os.path.isabs(filename):
   120|         0|            0|            0|  0.00%|            return []
   121|         0|            0|            0|  0.00%|
   122|         0|            0|            0|  0.00%|        for dirname in sys.path:
   123|         0|            0|            0|  0.00%|            try:
   124|         0|            0|            0|  0.00%|                fullname = os.path.join(dirname, basename)
   125|         0|            0|            0|  0.00%|            except (TypeError, AttributeError):
   126|         0|            0|            0|  0.00%|                # Not sufficiently string-like to do anything useful with.
   127|         0|            0|            0|  0.00%|                continue
   128|         0|            0|            0|  0.00%|            try:
   129|         0|            0|            0|  0.00%|                stat = os.stat(fullname)
   130|         0|            0|            0|  0.00%|                break
   131|         0|            0|            0|  0.00%|            except OSError:
   132|         0|            0|            0|  0.00%|                pass
   133|         0|            0|            0|  0.00%|        else:
   134|         0|            0|            0|  0.00%|            return []
   135|         1|            0|            0|  0.00%|    try:
   136|         1|            0|            0|  0.00%|        with tokenize.open(fullname) as fp:
(call)|         1|   0.00100112|   0.00100112|  0.01%|# C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.8_3.8.1520.0_x64__qbz5n2kfra8p0\lib\tokenize.py:388 open
   137|         1|            0|            0|  0.00%|            lines = fp.readlines()
(call)|        12|            0|            0|  0.00%|# C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.8_3.8.1520.0_x64__qbz5n2kfra8p0\lib\codecs.py:319 decode
   138|         0|            0|            0|  0.00%|    except OSError:
   139|         0|            0|            0|  0.00%|        return []
   140|         1|            0|            0|  0.00%|    if lines and not lines[-1].endswith('\n'):
   141|         0|            0|            0|  0.00%|        lines[-1] += '\n'
   142|         1|            0|            0|  0.00%|    size, mtime = stat.st_size, stat.st_mtime
   143|         1|            0|            0|  0.00%|    cache[filename] = size, mtime, lines, fullname
   144|         1|            0|            0|  0.00%|    return lines
   145|         0|            0|            0|  0.00%|
   146|         0|            0|            0|  0.00%|
   147|         0|            0|            0|  0.00%|def lazycache(filename, module_globals):
   148|         0|            0|            0|  0.00%|    """Seed the cache for filename with module_globals.
   149|         0|            0|            0|  0.00%|
   150|         0|            0|            0|  0.00%|    The module loader will be asked for the source only when getlines is
   151|         0|            0|            0|  0.00%|    called, not immediately.
   152|         0|            0|            0|  0.00%|
   153|         0|            0|            0|  0.00%|    If there is an entry in the cache already, it is not altered.
   154|         0|            0|            0|  0.00%|
   155|         0|            0|            0|  0.00%|    :return: True if a lazy load is registered in the cache,
   156|         0|            0|            0|  0.00%|        otherwise False. To register such a load a module loader with a
   157|         0|            0|            0|  0.00%|        get_source method must be found, the filename must be a cachable
   158|         0|            0|            0|  0.00%|        filename, and the filename must not be already cached.
   159|         0|            0|            0|  0.00%|    """
   160|         0|            0|            0|  0.00%|    if filename in cache:
   161|         0|            0|            0|  0.00%|        if len(cache[filename]) == 1:
   162|         0|            0|            0|  0.00%|            return True
   163|         0|            0|            0|  0.00%|        else:
   164|         0|            0|            0|  0.00%|            return False
   165|         0|            0|            0|  0.00%|    if not filename or (filename.startswith('<') and filename.endswith('>')):
   166|         0|            0|            0|  0.00%|        return False
   167|         0|            0|            0|  0.00%|    # Try for a __loader__, if available
   168|         0|            0|            0|  0.00%|    if module_globals and '__loader__' in module_globals:
   169|         0|            0|            0|  0.00%|        name = module_globals.get('__name__')
   170|         0|            0|            0|  0.00%|        loader = module_globals['__loader__']
   171|         0|            0|            0|  0.00%|        get_source = getattr(loader, 'get_source', None)
   172|         0|            0|            0|  0.00%|
   173|         0|            0|            0|  0.00%|        if name and get_source:
   174|         0|            0|            0|  0.00%|            get_lines = functools.partial(get_source, name)
   175|         0|            0|            0|  0.00%|            cache[filename] = (get_lines,)
   176|         0|            0|            0|  0.00%|            return True
   177|         0|            0|            0|  0.00%|    return False
